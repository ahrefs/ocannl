<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Backend_intf (arrayjit.Arrayjit.Backend_intf)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">arrayjit</a> &#x00BB; <a href="../index.html">Arrayjit</a> &#x00BB; Backend_intf</nav><header class="odoc-preamble"><h1>Module <code><span>Arrayjit.Backend_intf</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#the-interface-types-for-backends">The interface types for backends</a></li></ul></nav><div class="odoc-content"><h2 id="the-interface-types-for-backends"><a href="#the-interface-types-for-backends" class="anchor"></a>The interface types for backends</h2><p>User-facing backend API.</p><div class="odoc-spec"><div class="spec type anchored" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span><span class="keyword">type</span> <span>'buffer_ptr buffer</span></span><span> = </span><span>{</span></code><ol><li id="type-buffer.ptr" class="def record field anchored"><a href="#type-buffer.ptr" class="anchor"></a><code><span>ptr : <span class="type-var">'buffer_ptr</span>;</span></code></li><li id="type-buffer.size_in_bytes" class="def record field anchored"><a href="#type-buffer.size_in_bytes" class="anchor"></a><code><span>size_in_bytes : <span class="xref-unresolved">Base</span>.int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_buffer"><a href="#val-sexp_of_buffer" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_buffer : 
  'buffer_ptr. <span><span>(<span><span class="type-var">'buffer_ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'buffer_ptr</span> <a href="#type-buffer">buffer</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ctx_arrays"><a href="#type-ctx_arrays" class="anchor"></a><code><span><span class="keyword">type</span> <span>'buffer_ptr ctx_arrays</span></span><span> = <span><span class="type-var">'buffer_ptr</span> <span class="xref-unresolved">Base</span>.Map.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_ctx_arrays"><a href="#val-sexp_of_ctx_arrays" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_ctx_arrays : 
  'buffer_ptr. <span><span>(<span><span class="type-var">'buffer_ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'buffer_ptr</span> <a href="#type-ctx_arrays">ctx_arrays</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Buffer_types"><a href="#module-Buffer_types" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Buffer_types/index.html">Buffer_types</a></span><span> (<a href="Buffer_types/argument-1-Buffer_ptr/index.html">Buffer_ptr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Buffer"><a href="#module-type-Buffer" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Buffer/index.html">Buffer</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Alloc_buffer"><a href="#module-type-Alloc_buffer" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Alloc_buffer/index.html">Alloc_buffer</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-config"><a href="#type-config" class="anchor"></a><code><span><span class="keyword">type</span> config</span><span> = </span></code><ol><li id="type-config.Only_devices_parallel" class="def variant constructor anchored"><a href="#type-config.Only_devices_parallel" class="anchor"></a><code><span>| </span><span><span class="constructor">Only_devices_parallel</span></span></code></li><li id="type-config.For_parallel_copying" class="def variant constructor anchored"><a href="#type-config.For_parallel_copying" class="anchor"></a><code><span>| </span><span><span class="constructor">For_parallel_copying</span></span></code></li><li id="type-config.Most_parallel_streams" class="def variant constructor anchored"><a href="#type-config.Most_parallel_streams" class="anchor"></a><code><span>| </span><span><span class="constructor">Most_parallel_streams</span></span></code></li></ol></div><div class="spec-doc"><p>For now, we only configure a backend with regard to how many streams it should suggest using (where applicable).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_config"><a href="#val-equal_config" class="anchor"></a><code><span><span class="keyword">val</span> equal_config : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-config_of_sexp"><a href="#val-config_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> config_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-config">config</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_config"><a href="#val-sexp_of_config" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_config : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-only_devices_parallel"><a href="#val-only_devices_parallel" class="anchor"></a><code><span><span class="keyword">val</span> only_devices_parallel : <a href="#type-config">config</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_parallel_copying"><a href="#val-for_parallel_copying" class="anchor"></a><code><span><span class="keyword">val</span> for_parallel_copying : <a href="#type-config">config</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-most_parallel_streams"><a href="#val-most_parallel_streams" class="anchor"></a><code><span><span class="keyword">val</span> most_parallel_streams : <a href="#type-config">config</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_only_devices_parallel"><a href="#val-is_only_devices_parallel" class="anchor"></a><code><span><span class="keyword">val</span> is_only_devices_parallel : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_for_parallel_copying"><a href="#val-is_for_parallel_copying" class="anchor"></a><code><span><span class="keyword">val</span> is_for_parallel_copying : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_most_parallel_streams"><a href="#val-is_most_parallel_streams" class="anchor"></a><code><span><span class="keyword">val</span> is_most_parallel_streams : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-only_devices_parallel_val"><a href="#val-only_devices_parallel_val" class="anchor"></a><code><span><span class="keyword">val</span> only_devices_parallel_val : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Stdlib</span>.Option.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_parallel_copying_val"><a href="#val-for_parallel_copying_val" class="anchor"></a><code><span><span class="keyword">val</span> for_parallel_copying_val : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Stdlib</span>.Option.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-most_parallel_streams_val"><a href="#val-most_parallel_streams_val" class="anchor"></a><code><span><span class="keyword">val</span> most_parallel_streams_val : <span><a href="#type-config">config</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Stdlib</span>.Option.t</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Variants_of_config"><a href="#module-Variants_of_config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Variants_of_config/index.html">Variants_of_config</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-merge_buffer_use"><a href="#type-merge_buffer_use" class="anchor"></a><code><span><span class="keyword">type</span> merge_buffer_use</span><span> = </span></code><ol><li id="type-merge_buffer_use.No" class="def variant constructor anchored"><a href="#type-merge_buffer_use.No" class="anchor"></a><code><span>| </span><span><span class="constructor">No</span></span></code></li><li id="type-merge_buffer_use.Streaming" class="def variant constructor anchored"><a href="#type-merge_buffer_use.Streaming" class="anchor"></a><code><span>| </span><span><span class="constructor">Streaming</span></span></code></li><li id="type-merge_buffer_use.Copy" class="def variant constructor anchored"><a href="#type-merge_buffer_use.Copy" class="anchor"></a><code><span>| </span><span><span class="constructor">Copy</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_merge_buffer_use"><a href="#val-equal_merge_buffer_use" class="anchor"></a><code><span><span class="keyword">val</span> equal_merge_buffer_use : <span><a href="#type-merge_buffer_use">merge_buffer_use</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-merge_buffer_use">merge_buffer_use</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_buffer_use_of_sexp"><a href="#val-merge_buffer_use_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> merge_buffer_use_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-merge_buffer_use">merge_buffer_use</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_merge_buffer_use"><a href="#val-sexp_of_merge_buffer_use" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_merge_buffer_use : <span><a href="#type-merge_buffer_use">merge_buffer_use</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-param_source"><a href="#type-param_source" class="anchor"></a><code><span><span class="keyword">type</span> param_source</span><span> = </span></code><ol><li id="type-param_source.Log_file_name" class="def variant constructor anchored"><a href="#type-param_source.Log_file_name" class="anchor"></a><code><span>| </span><span><span class="constructor">Log_file_name</span></span></code></li><li id="type-param_source.Merge_buffer" class="def variant constructor anchored"><a href="#type-param_source.Merge_buffer" class="anchor"></a><code><span>| </span><span><span class="constructor">Merge_buffer</span></span></code></li><li id="type-param_source.Param_ptr" class="def variant constructor anchored"><a href="#type-param_source.Param_ptr" class="anchor"></a><code><span>| </span><span><span class="constructor">Param_ptr</span> <span class="keyword">of</span> <a href="../Tnode/index.html#type-t">Tnode.t</a></span></code></li><li id="type-param_source.Static_idx" class="def variant constructor anchored"><a href="#type-param_source.Static_idx" class="anchor"></a><code><span>| </span><span><span class="constructor">Static_idx</span> <span class="keyword">of</span> <a href="../Indexing/index.html#type-static_symbol">Indexing.static_symbol</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_param_source"><a href="#val-sexp_of_param_source" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_param_source : <span><a href="#type-param_source">param_source</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-routine"><a href="#type-routine" class="anchor"></a><code><span><span class="keyword">type</span> <span>'context routine</span></span><span> = </span><span>{</span></code><ol><li id="type-routine.context" class="def record field anchored"><a href="#type-routine.context" class="anchor"></a><code><span>context : <span class="type-var">'context</span>;</span></code></li><li id="type-routine.schedule" class="def record field anchored"><a href="#type-routine.schedule" class="anchor"></a><code><span>schedule : <a href="../Task/index.html#type-t">Task.t</a>;</span></code></li><li id="type-routine.bindings" class="def record field anchored"><a href="#type-routine.bindings" class="anchor"></a><code><span>bindings : <a href="../Indexing/index.html#type-lowered_bindings">Indexing.lowered_bindings</a>;</span></code></li><li id="type-routine.name" class="def record field anchored"><a href="#type-routine.name" class="anchor"></a><code><span>name : <span class="xref-unresolved">Base</span>.string;</span></code></li><li id="type-routine.inputs" class="def record field anchored"><a href="#type-routine.inputs" class="anchor"></a><code><span>inputs : <span class="xref-unresolved">Base</span>.Set.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The materialized read-only and read-before-write (within the routine) non-constant nodes. They are inputs in a broad sense, as they could be recurrent nodes or parameters.</p><span class="comment-delim">*)</span></div></li><li id="type-routine.merge_buffer_input" class="def record field anchored"><a href="#type-routine.merge_buffer_input" class="anchor"></a><code><span>merge_buffer_input : <span><a href="../Tnode/index.html#type-t">Tnode.t</a> <span class="xref-unresolved">Base</span>.option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Similar to <a href="#type-routine.inputs"><code>inputs</code></a>, for the merge buffer.</p><span class="comment-delim">*)</span></div></li><li id="type-routine.outputs" class="def record field anchored"><a href="#type-routine.outputs" class="anchor"></a><code><span>outputs : <span class="xref-unresolved">Base</span>.Set.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>All the materialized nodes written-to by the routine.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_routine"><a href="#val-sexp_of_routine" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_routine : 
  'context. <span><span>(<span><span class="type-var">'context</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'context</span> <a href="#type-routine">routine</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Device_config"><a href="#module-type-Device_config" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Device_config/index.html">Device_config</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-device_ref"><a href="#type-device_ref" class="anchor"></a><code><span><span class="keyword">type</span> <span>('buffer_ptr, 'dev, 'runner, 'event) device_ref</span></span><span> = </span><span>{</span></code><ol><li id="type-device_ref.dev" class="def record field anchored"><a href="#type-device_ref.dev" class="anchor"></a><code><span>dev : <span class="type-var">'dev</span>;</span></code></li><li id="type-device_ref.ordinal" class="def record field anchored"><a href="#type-device_ref.ordinal" class="anchor"></a><code><span>ordinal : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-device_ref.latest_stream_id" class="def record field anchored"><a href="#type-device_ref.latest_stream_id" class="anchor"></a><code><span><span class="keyword">mutable</span> latest_stream_id : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-device_ref.released" class="def record field anchored"><a href="#type-device_ref.released" class="anchor"></a><code><span>released : <a href="../Utils/index.html#type-atomic_bool">Utils.atomic_bool</a>;</span></code></li><li id="type-device_ref.cross_stream_candidates" class="def record field anchored"><a href="#type-device_ref.cross_stream_candidates" class="anchor"></a><code><span>cross_stream_candidates : <span><span class="type-var">'buffer_ptr</span> <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-device_ref.owner_stream" class="def record field anchored"><a href="#type-device_ref.owner_stream" class="anchor"></a><code><span>owner_stream : <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                 <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-device_ref.shared_writer_streams" class="def record field anchored"><a href="#type-device_ref.shared_writer_streams" class="anchor"></a><code><span>shared_writer_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                         * <span class="type-var">'event</span>)</span>
                          <span class="xref-unresolved">Base</span>.list</span>
                          <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-device_ref.host_reading_streams" class="def record field anchored"><a href="#type-device_ref.host_reading_streams" class="anchor"></a><code><span>host_reading_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                        * <span class="type-var">'event</span>)</span>
                         <span class="xref-unresolved">Base</span>.list</span>
                         <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-device_ref.host_writing_streams" class="def record field anchored"><a href="#type-device_ref.host_writing_streams" class="anchor"></a><code><span>host_writing_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                        * <span class="type-var">'event</span>)</span>
                         <span class="xref-unresolved">Base</span>.list</span>
                         <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stream_ref"><a href="#type-stream_ref" class="anchor"></a><code><span><span class="keyword">and</span> <span>('buffer_ptr, 'dev, 'runner, 'event) stream_ref</span></span><span> = </span><span>{</span></code><ol><li id="type-stream_ref.device" class="def record field anchored"><a href="#type-stream_ref.device" class="anchor"></a><code><span>device : <span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-device_ref">device_ref</a></span>;</span></code></li><li id="type-stream_ref.runner" class="def record field anchored"><a href="#type-stream_ref.runner" class="anchor"></a><code><span>runner : <span class="type-var">'runner</span>;</span></code></li><li id="type-stream_ref.merge_buffer" class="def record field anchored"><a href="#type-stream_ref.merge_buffer" class="anchor"></a><code><span>merge_buffer : <span><span><span><span class="type-var">'buffer_ptr</span> <a href="#type-buffer">buffer</a></span> <span class="xref-unresolved">Base</span>.option</span> <span class="xref-unresolved">Base</span>.ref</span>;</span></code></li><li id="type-stream_ref.stream_id" class="def record field anchored"><a href="#type-stream_ref.stream_id" class="anchor"></a><code><span>stream_id : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-stream_ref.allocated_buffer" class="def record field anchored"><a href="#type-stream_ref.allocated_buffer" class="anchor"></a><code><span><span class="keyword">mutable</span> allocated_buffer : <span><span><span class="type-var">'buffer_ptr</span> <a href="#type-buffer">buffer</a></span> <span class="xref-unresolved">Base</span>.option</span>;</span></code></li><li id="type-stream_ref.updating_for" class="def record field anchored"><a href="#type-stream_ref.updating_for" class="anchor"></a><code><span>updating_for : <span><span class="type-var">'event</span> <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-stream_ref.updating_for_merge_buffer" class="def record field anchored"><a href="#type-stream_ref.updating_for_merge_buffer" class="anchor"></a><code><span><span class="keyword">mutable</span> updating_for_merge_buffer : <span><span>(<a href="../Tnode/index.html#type-t">Tnode.t</a> * <span class="type-var">'event</span>)</span> <span class="xref-unresolved">Base</span>.option</span>;</span></code></li><li id="type-stream_ref.reader_streams" class="def record field anchored"><a href="#type-stream_ref.reader_streams" class="anchor"></a><code><span>reader_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> * <span class="type-var">'event</span>)</span>
                   <span class="xref-unresolved">Base</span>.list</span>
                   <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_device_ref"><a href="#val-sexp_of_device_ref" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_device_ref : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>, <span class="type-var">'h</span>)</span> <a href="#type-device_ref">device_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_stream_ref"><a href="#val-sexp_of_stream_ref" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_stream_ref : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>, <span class="type-var">'h</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_stream_ref"><a href="#val-equal_stream_ref" class="anchor"></a><code><span><span class="keyword">val</span> equal_stream_ref : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>, <span class="type-var">'h</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-device"><a href="#type-device" class="anchor"></a><code><span><span class="keyword">type</span> <span>('buffer_ptr, 'dev, 'runner, 'event) device</span></span><span> =
  <span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-device_ref">device_ref</a></span></span><span> =
  </span><span>{</span></code><ol><li id="type-device.dev" class="def record field anchored"><a href="#type-device.dev" class="anchor"></a><code><span>dev : <span class="type-var">'dev</span>;</span></code></li><li id="type-device.ordinal" class="def record field anchored"><a href="#type-device.ordinal" class="anchor"></a><code><span>ordinal : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-device.latest_stream_id" class="def record field anchored"><a href="#type-device.latest_stream_id" class="anchor"></a><code><span><span class="keyword">mutable</span> latest_stream_id : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-device.released" class="def record field anchored"><a href="#type-device.released" class="anchor"></a><code><span>released : <a href="../Utils/index.html#type-atomic_bool">Utils.atomic_bool</a>;</span></code></li><li id="type-device.cross_stream_candidates" class="def record field anchored"><a href="#type-device.cross_stream_candidates" class="anchor"></a><code><span>cross_stream_candidates : <span><span class="type-var">'buffer_ptr</span> <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Freshly created arrays that might be shared across streams. The map can both grow and shrink.</p><span class="comment-delim">*)</span></div></li><li id="type-device.owner_stream" class="def record field anchored"><a href="#type-device.owner_stream" class="anchor"></a><code><span>owner_stream : <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                 <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The stream owning a given node. This map can only grow. Currently, if the memory mode of a node is inferred, only this stream will modify a cross-stream shared array. But memory modes can also be set manually.</p><span class="comment-delim">*)</span></div></li><li id="type-device.shared_writer_streams" class="def record field anchored"><a href="#type-device.shared_writer_streams" class="anchor"></a><code><span>shared_writer_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                         * <span class="type-var">'event</span>)</span>
                          <span class="xref-unresolved">Base</span>.list</span>
                          <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The streams that most recently have been scheduled to update (write to) a cross-stream-shared node, and the associated update completion event. The completed events are removed opportunistically.</p><span class="comment-delim">*)</span></div></li><li id="type-device.host_reading_streams" class="def record field anchored"><a href="#type-device.host_reading_streams" class="anchor"></a><code><span>host_reading_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                        * <span class="type-var">'event</span>)</span>
                         <span class="xref-unresolved">Base</span>.list</span>
                         <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The streams that most recently have been reading from a node's on-host array. The completed events are removed opportunistically.</p><span class="comment-delim">*)</span></div></li><li id="type-device.host_writing_streams" class="def record field anchored"><a href="#type-device.host_writing_streams" class="anchor"></a><code><span>host_writing_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span>
                        * <span class="type-var">'event</span>)</span>
                         <span class="xref-unresolved">Base</span>.list</span>
                         <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The streams that most recently have been writing to a node's on-host array. The completed events are removed opportunistically.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_device"><a href="#val-sexp_of_device" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_device : 
  'buffer_ptr 'dev 'runner 'event. <span><span>(<span><span class="type-var">'buffer_ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'dev</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'runner</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'event</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-device">device</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> <span>('buffer_ptr, 'dev, 'runner, 'event) stream</span></span><span> =
  <span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span></span><span> =
  </span><span>{</span></code><ol><li id="type-stream.device" class="def record field anchored"><a href="#type-stream.device" class="anchor"></a><code><span>device : <span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-device_ref">device_ref</a></span>;</span></code></li><li id="type-stream.runner" class="def record field anchored"><a href="#type-stream.runner" class="anchor"></a><code><span>runner : <span class="type-var">'runner</span>;</span></code></li><li id="type-stream.merge_buffer" class="def record field anchored"><a href="#type-stream.merge_buffer" class="anchor"></a><code><span>merge_buffer : <span><span><span><span class="type-var">'buffer_ptr</span> <a href="#type-buffer">buffer</a></span> <span class="xref-unresolved">Base</span>.option</span> <span class="xref-unresolved">Base</span>.ref</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Depending on backend implementations, either the currently used merge buffer, or the one most recently scheduled. Note that the pointer can be reused for nodes that fit in an already allocated buffer.</p><span class="comment-delim">*)</span></div></li><li id="type-stream.stream_id" class="def record field anchored"><a href="#type-stream.stream_id" class="anchor"></a><code><span>stream_id : <span class="xref-unresolved">Base</span>.int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An ID unique within the device.</p><span class="comment-delim">*)</span></div></li><li id="type-stream.allocated_buffer" class="def record field anchored"><a href="#type-stream.allocated_buffer" class="anchor"></a><code><span><span class="keyword">mutable</span> allocated_buffer : <span><span><span class="type-var">'buffer_ptr</span> <a href="#type-buffer">buffer</a></span> <span class="xref-unresolved">Base</span>.option</span>;</span></code></li><li id="type-stream.updating_for" class="def record field anchored"><a href="#type-stream.updating_for" class="anchor"></a><code><span>updating_for : <span><span class="type-var">'event</span> <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code></li><li id="type-stream.updating_for_merge_buffer" class="def record field anchored"><a href="#type-stream.updating_for_merge_buffer" class="anchor"></a><code><span><span class="keyword">mutable</span> updating_for_merge_buffer : <span><span>(<a href="../Tnode/index.html#type-t">Tnode.t</a> * <span class="type-var">'event</span>)</span> <span class="xref-unresolved">Base</span>.option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The tensor node that was most recently scheduled to be in the <code>stream</code>'s merge buffer and its updating completion event. See also <a href="#type-stream.updating_for"><code>updating_for</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-stream.reader_streams" class="def record field anchored"><a href="#type-stream.reader_streams" class="anchor"></a><code><span>reader_streams : <span><span><span>(<span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> * <span class="type-var">'event</span>)</span>
                   <span class="xref-unresolved">Base</span>.list</span>
                   <span class="xref-unresolved">Base</span>.Hashtbl.M(<span class="xref-unresolved">Arrayjit</span>.Tnode).t</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The streams, other than this stream, that most recently have been reading from a node in this stream's context, and the associated use completion events. The completed events are removed opportunistically.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_stream"><a href="#val-sexp_of_stream" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_stream : 
  'buffer_ptr 'dev 'runner 'event. <span><span>(<span><span class="type-var">'buffer_ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'dev</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'runner</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'event</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'dev</span>, <span class="type-var">'runner</span>, <span class="type-var">'event</span>)</span> <a href="#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_stream"><a href="#val-equal_stream" class="anchor"></a><code><span><span class="keyword">val</span> equal_stream : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'e</span>, <span class="type-var">'f</span>, <span class="type-var">'g</span>, <span class="type-var">'h</span>)</span> <a href="#type-stream_ref">stream_ref</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">type</span> <span>('buffer_ptr, 'stream) context</span></span><span> = </span><span>{</span></code><ol><li id="type-context.stream" class="def record field anchored"><a href="#type-context.stream" class="anchor"></a><code><span>stream : <span class="type-var">'stream</span>;</span></code></li><li id="type-context.parent" class="def record field anchored"><a href="#type-context.parent" class="anchor"></a><code><span>parent : <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'stream</span>)</span> <a href="#type-context">context</a></span> <span class="xref-unresolved">Base</span>.option</span>;</span></code></li><li id="type-context.ctx_arrays" class="def record field anchored"><a href="#type-context.ctx_arrays" class="anchor"></a><code><span>ctx_arrays : <span><span class="type-var">'buffer_ptr</span> <a href="#type-ctx_arrays">ctx_arrays</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This map contains arrays used in this context or an ancestor context (they might be unique but might also be cross-stream shared.</p><span class="comment-delim">*)</span></div></li><li id="type-context.finalized" class="def record field anchored"><a href="#type-context.finalized" class="anchor"></a><code><span>finalized : <a href="../Utils/index.html#type-atomic_bool">Utils.atomic_bool</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_context"><a href="#val-sexp_of_context" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_context : 
  'buffer_ptr 'stream. <span><span>(<span><span class="type-var">'buffer_ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'stream</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'buffer_ptr</span>, <span class="type-var">'stream</span>)</span> <a href="#type-context">context</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Device_types"><a href="#module-type-Device_types" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Device_types/index.html">Device_types</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Device"><a href="#module-type-Device" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Device/index.html">Device</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Backend_any_common"><a href="#module-type-Backend_any_common" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Backend_any_common/index.html">Backend_any_common</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Parts shared by both assignments-level and lowered-level backend interfaces.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Backend_common"><a href="#module-type-Backend_common" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Backend_common/index.html">Backend_common</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Parts shared by assignments-level backend interfaces.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Backend_device_common"><a href="#module-type-Backend_device_common" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Backend_device_common/index.html">Backend_device_common</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Parts shared by both assignments-level and lowered-level backend interfaces providing streams and devices, both user-facing and implementation-facing. Does not include: compilation and linking (differnt for assignments-level and lowered-level); copying and tensor-node-level synchronization (copying is different for user-facing and implementation-facing APIs, synchronization is provided by a component outside of backend implementations).</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-With_buffer_retrieval_and_syncing"><a href="#module-type-With_buffer_retrieval_and_syncing" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-With_buffer_retrieval_and_syncing/index.html">With_buffer_retrieval_and_syncing</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Backend"><a href="#module-type-Backend" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Backend/index.html">Backend</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
