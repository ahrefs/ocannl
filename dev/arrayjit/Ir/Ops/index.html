<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ops (arrayjit.Ir.Ops)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">arrayjit</a> &#x00BB; <a href="../index.html">Ir</a> &#x00BB; Ops</nav><header class="odoc-preamble"><h1>Module <code><span>Ir.Ops</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#***-precision-***">*** Precision ***</a></li><li><a href="#***-operations-***">*** Operations ***</a></li><li><a href="#***-pointer-representation-***">*** Pointer representation ***</a></li><li><a href="#***-external-ffi-declarations-***">*** External FFI declarations ***</a></li><li><a href="#***-precision-homogeneity-classification-***">*** Precision homogeneity classification ***</a></li></ul></nav></div><div class="odoc-content"><p>Operation types shared by all backends; and precision types.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Lazy"><a href="#module-Lazy" class="anchor"></a><code><span><span class="keyword">module</span> Lazy</span><span> = <a href="../../Utils/Lazy/index.html">Utils.Lazy</a></span></code></div></div><h3 id="***-precision-***"><a href="#***-precision-***" class="anchor"></a>*** Precision ***</h3><div class="odoc-spec"><div class="spec type anchored" id="type-uint8_elt"><a href="#type-uint8_elt" class="anchor"></a><code><span><span class="keyword">type</span> uint8_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-uint16_elt"><a href="#type-uint16_elt" class="anchor"></a><code><span><span class="keyword">type</span> uint16_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.int16_unsigned_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-int32_elt"><a href="#type-int32_elt" class="anchor"></a><code><span><span class="keyword">type</span> int32_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.int32_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-float16_elt"><a href="#type-float16_elt" class="anchor"></a><code><span><span class="keyword">type</span> float16_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.float16_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-float32_elt"><a href="#type-float32_elt" class="anchor"></a><code><span><span class="keyword">type</span> float32_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.float32_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-float64_elt"><a href="#type-float64_elt" class="anchor"></a><code><span><span class="keyword">type</span> float64_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.float64_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-int64_elt"><a href="#type-int64_elt" class="anchor"></a><code><span><span class="keyword">type</span> int64_elt</span><span> = <span class="xref-unresolved">Stdlib</span>.Bigarray.int64_elt</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-precision"><a href="#type-precision" class="anchor"></a><code><span><span class="keyword">type</span> <span>('ocaml, 'impl) precision</span></span><span> = </span></code><ol><li id="type-precision.Byte" class="def variant constructor anchored"><a href="#type-precision.Byte" class="anchor"></a><code><span>| </span><span><span class="constructor">Byte</span> : <span><span>(<span class="xref-unresolved">Base</span>.char, <a href="#type-uint8_elt">uint8_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Uint16" class="def variant constructor anchored"><a href="#type-precision.Uint16" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint16</span> : <span><span>(<span class="xref-unresolved">Base</span>.int, <a href="#type-uint16_elt">uint16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Int32" class="def variant constructor anchored"><a href="#type-precision.Int32" class="anchor"></a><code><span>| </span><span><span class="constructor">Int32</span> : <span><span>(<span class="xref-unresolved">Base</span>.int32, <a href="#type-int32_elt">int32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Uint32" class="def variant constructor anchored"><a href="#type-precision.Uint32" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint32</span> : <span><span>(<span class="xref-unresolved">Base</span>.int32, <a href="#type-int32_elt">int32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Using int32_elt representation but treating as unsigned</p><span class="comment-delim">*)</span></div></li><li id="type-precision.Int64" class="def variant constructor anchored"><a href="#type-precision.Int64" class="anchor"></a><code><span>| </span><span><span class="constructor">Int64</span> : <span><span>(<span class="xref-unresolved">Base</span>.int64, <a href="#type-int64_elt">int64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Uint64" class="def variant constructor anchored"><a href="#type-precision.Uint64" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint64</span> : <span><span>(<span class="xref-unresolved">Base</span>.int64, <a href="#type-int64_elt">int64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Using int64_elt representation but treating as unsigned</p><span class="comment-delim">*)</span></div></li><li id="type-precision.Uint4x32" class="def variant constructor anchored"><a href="#type-precision.Uint4x32" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint4x32</span> : <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="xref-unresolved">Stdlib</span>.Bigarray.complex64_elt)</span> <a href="#type-precision">precision</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A 128-bit value that corresponds to e.g. CUDA's uint4 type. Luckily, the OCaml Bigarray library supports complex64_elt which is a 128-bit value, so we avoid dims conversions.</p><span class="comment-delim">*)</span></div></li><li id="type-precision.Half" class="def variant constructor anchored"><a href="#type-precision.Half" class="anchor"></a><code><span>| </span><span><span class="constructor">Half</span> : <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float16_elt">float16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Bfloat16" class="def variant constructor anchored"><a href="#type-precision.Bfloat16" class="anchor"></a><code><span>| </span><span><span class="constructor">Bfloat16</span> : <span><span>(<span class="xref-unresolved">Base</span>.int, <a href="#type-uint16_elt">uint16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Using uint16 representation for now</p><span class="comment-delim">*)</span></div></li><li id="type-precision.Fp8" class="def variant constructor anchored"><a href="#type-precision.Fp8" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp8</span> : <span><span>(<span class="xref-unresolved">Base</span>.char, <a href="#type-uint8_elt">uint8_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Using uint8 representation for now</p><span class="comment-delim">*)</span></div></li><li id="type-precision.Single" class="def variant constructor anchored"><a href="#type-precision.Single" class="anchor"></a><code><span>| </span><span><span class="constructor">Single</span> : <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float32_elt">float32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-precision.Double" class="def variant constructor anchored"><a href="#type-precision.Double" class="anchor"></a><code><span>| </span><span><span class="constructor">Double</span> : <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float64_elt">float64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_precision"><a href="#val-sexp_of_precision" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_precision : 
  'ocaml 'impl. <span><span>(<span><span class="type-var">'ocaml</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'impl</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'ocaml</span>, <span class="type-var">'impl</span>)</span> <a href="#type-precision">precision</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-prec"><a href="#type-prec" class="anchor"></a><code><span><span class="keyword">type</span> prec</span><span> = </span></code><ol><li id="type-prec.Void_prec" class="def variant constructor anchored"><a href="#type-prec.Void_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Void_prec</span></span></code></li><li id="type-prec.Byte_prec" class="def variant constructor anchored"><a href="#type-prec.Byte_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Byte_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.char, <a href="#type-uint8_elt">uint8_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Uint16_prec" class="def variant constructor anchored"><a href="#type-prec.Uint16_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint16_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int, <a href="#type-uint16_elt">uint16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Int32_prec" class="def variant constructor anchored"><a href="#type-prec.Int32_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Int32_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int32, <a href="#type-int32_elt">int32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Uint32_prec" class="def variant constructor anchored"><a href="#type-prec.Uint32_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint32_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int32, <a href="#type-int32_elt">int32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Int64_prec" class="def variant constructor anchored"><a href="#type-prec.Int64_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Int64_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int64, <a href="#type-int64_elt">int64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Uint64_prec" class="def variant constructor anchored"><a href="#type-prec.Uint64_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint64_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int64, <a href="#type-int64_elt">int64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Uint4x32_prec" class="def variant constructor anchored"><a href="#type-prec.Uint4x32_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint4x32_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Stdlib</span>.Complex.t, <span class="xref-unresolved">Stdlib</span>.Bigarray.complex64_elt)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Half_prec" class="def variant constructor anchored"><a href="#type-prec.Half_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Half_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float16_elt">float16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Bfloat16_prec" class="def variant constructor anchored"><a href="#type-prec.Bfloat16_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Bfloat16_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.int, <a href="#type-uint16_elt">uint16_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Fp8_prec" class="def variant constructor anchored"><a href="#type-prec.Fp8_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp8_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.char, <a href="#type-uint8_elt">uint8_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Single_prec" class="def variant constructor anchored"><a href="#type-prec.Single_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Single_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float32_elt">float32_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li><li id="type-prec.Double_prec" class="def variant constructor anchored"><a href="#type-prec.Double_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Double_prec</span> <span class="keyword">of</span> <span><span>(<span class="xref-unresolved">Base</span>.float, <a href="#type-float64_elt">float64_elt</a>)</span> <a href="#type-precision">precision</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-byte"><a href="#val-byte" class="anchor"></a><code><span><span class="keyword">val</span> byte : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint16"><a href="#val-uint16" class="anchor"></a><code><span><span class="keyword">val</span> uint16 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint32"><a href="#val-uint32" class="anchor"></a><code><span><span class="keyword">val</span> uint32 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint64"><a href="#val-uint64" class="anchor"></a><code><span><span class="keyword">val</span> uint64 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint4x32"><a href="#val-uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-half"><a href="#val-half" class="anchor"></a><code><span><span class="keyword">val</span> half : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bfloat16"><a href="#val-bfloat16" class="anchor"></a><code><span><span class="keyword">val</span> bfloat16 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fp8"><a href="#val-fp8" class="anchor"></a><code><span><span class="keyword">val</span> fp8 : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-single"><a href="#val-single" class="anchor"></a><code><span><span class="keyword">val</span> single : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-double"><a href="#val-double" class="anchor"></a><code><span><span class="keyword">val</span> double : <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index_prec"><a href="#val-index_prec" class="anchor"></a><code><span><span class="keyword">val</span> index_prec : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-prec">prec</a></span></code></div><div class="spec-doc"><p>Returns the precision to use for indexing arithmetic based on the big_models setting.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_up_to_fp16"><a href="#val-is_up_to_fp16" class="anchor"></a><code><span><span class="keyword">val</span> is_up_to_fp16 : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exceeds_fp16_cutoff"><a href="#val-exceeds_fp16_cutoff" class="anchor"></a><code><span><span class="keyword">val</span> exceeds_fp16_cutoff : <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_prec"><a href="#val-sexp_of_prec" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prec_of_sexp"><a href="#val-prec_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> prec_of_sexp : <span><span class="xref-unresolved">Base</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-precision_to_string"><a href="#val-precision_to_string" class="anchor"></a><code><span><span class="keyword">val</span> precision_to_string : <span><span><span>(<span class="type-var">'ocaml</span>, <span class="type-var">'elt_t</span>)</span> <a href="#type-precision">precision</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prec_string"><a href="#val-prec_string" class="anchor"></a><code><span><span class="keyword">val</span> prec_string : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prec_of_string"><a href="#val-prec_of_string" class="anchor"></a><code><span><span class="keyword">val</span> prec_of_string : <span><span class="xref-unresolved">Base</span>.String.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_prec"><a href="#val-equal_prec" class="anchor"></a><code><span><span class="keyword">val</span> equal_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_prec"><a href="#val-compare_prec" class="anchor"></a><code><span><span class="keyword">val</span> compare_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prec_in_bytes"><a href="#val-prec_in_bytes" class="anchor"></a><code><span><span class="keyword">val</span> prec_in_bytes : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_float"><a href="#val-is_float" class="anchor"></a><code><span><span class="keyword">val</span> is_float : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-promote_prec"><a href="#val-promote_prec" class="anchor"></a><code><span><span class="keyword">val</span> promote_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-prec">prec</a></span></code></div><div class="spec-doc"><p>Prefer precision which is more likely to remain functional in the resulting computations. uint4x32 always dominates, because operations that work on uint4x32 do not support other precisions. Otherwise, fractional number precisions dominate; within them, larger dynamic range precisions dominate.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pack_prec"><a href="#val-pack_prec" class="anchor"></a><code><span><span class="keyword">val</span> pack_prec : <span><span><span>(<span class="type-var">'ocaml</span>, <span class="type-var">'elt_t</span>)</span> <a href="#type-precision">precision</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-prec">prec</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-apply_prec"><a href="#type-apply_prec" class="anchor"></a><code><span><span class="keyword">type</span> <span>'r apply_prec</span></span><span> = </span><span>{</span></code><ol><li id="type-apply_prec.f" class="def record field anchored"><a href="#type-apply_prec.f" class="anchor"></a><code><span>f : 'ocaml 'elt_t. <span><span><span>(<span class="type-var">'ocaml</span>, <span class="type-var">'elt_t</span>)</span> <a href="#type-precision">precision</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_prec"><a href="#val-apply_prec" class="anchor"></a><code><span><span class="keyword">val</span> apply_prec : <span><span class="optlabel">?default</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-apply_prec">apply_prec</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-c_typ_of_prec"><a href="#val-c_typ_of_prec" class="anchor"></a><code><span><span class="keyword">val</span> c_typ_of_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-c_vec_typ_of_prec"><a href="#val-c_vec_typ_of_prec" class="anchor"></a><code><span><span class="keyword">val</span> c_vec_typ_of_prec : <span><span class="label">length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hum_typ_of_prec"><a href="#val-hum_typ_of_prec" class="anchor"></a><code><span><span class="keyword">val</span> hum_typ_of_prec : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><h3 id="***-operations-***"><a href="#***-operations-***" class="anchor"></a>*** Operations ***</h3><p>See: <a href="https://github.com/tinygrad/tinygrad/blob/master/tinygrad/ops.py#L123">tinygrad ops</a>, <a href="https://docs.nvidia.com/cuda/cuda-math-api/index.html">CUDA Math API</a> (intrinsics).</p><p>This is a redundant set of operations, aiming to expose hardware-supported &quot;intrinsics&quot;, to reduce the need for backends to pattern-match and optimize. Also for convenience.</p><div class="odoc-spec"><div class="spec type anchored" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">type</span> binop</span><span> = </span></code><ol><li id="type-binop.Arg1" class="def variant constructor anchored"><a href="#type-binop.Arg1" class="anchor"></a><code><span>| </span><span><span class="constructor">Arg1</span></span></code></li><li id="type-binop.Arg2" class="def variant constructor anchored"><a href="#type-binop.Arg2" class="anchor"></a><code><span>| </span><span><span class="constructor">Arg2</span></span></code></li><li id="type-binop.Add" class="def variant constructor anchored"><a href="#type-binop.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code></li><li id="type-binop.Sub" class="def variant constructor anchored"><a href="#type-binop.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code></li><li id="type-binop.Mul" class="def variant constructor anchored"><a href="#type-binop.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code></li><li id="type-binop.Div" class="def variant constructor anchored"><a href="#type-binop.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code></li><li id="type-binop.ToPowOf" class="def variant constructor anchored"><a href="#type-binop.ToPowOf" class="anchor"></a><code><span>| </span><span><span class="constructor">ToPowOf</span></span></code></li><li id="type-binop.Relu_gate" class="def variant constructor anchored"><a href="#type-binop.Relu_gate" class="anchor"></a><code><span>| </span><span><span class="constructor">Relu_gate</span></span></code></li><li id="type-binop.Satur01_gate" class="def variant constructor anchored"><a href="#type-binop.Satur01_gate" class="anchor"></a><code><span>| </span><span><span class="constructor">Satur01_gate</span></span></code></li><li id="type-binop.Max" class="def variant constructor anchored"><a href="#type-binop.Max" class="anchor"></a><code><span>| </span><span><span class="constructor">Max</span></span></code></li><li id="type-binop.Min" class="def variant constructor anchored"><a href="#type-binop.Min" class="anchor"></a><code><span>| </span><span><span class="constructor">Min</span></span></code></li><li id="type-binop.Mod" class="def variant constructor anchored"><a href="#type-binop.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code></li><li id="type-binop.Cmplt" class="def variant constructor anchored"><a href="#type-binop.Cmplt" class="anchor"></a><code><span>| </span><span><span class="constructor">Cmplt</span></span></code></li><li id="type-binop.Cmpeq" class="def variant constructor anchored"><a href="#type-binop.Cmpeq" class="anchor"></a><code><span>| </span><span><span class="constructor">Cmpeq</span></span></code></li><li id="type-binop.Cmpne" class="def variant constructor anchored"><a href="#type-binop.Cmpne" class="anchor"></a><code><span>| </span><span><span class="constructor">Cmpne</span></span></code></li><li id="type-binop.Or" class="def variant constructor anchored"><a href="#type-binop.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code></li><li id="type-binop.And" class="def variant constructor anchored"><a href="#type-binop.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code></li><li id="type-binop.Threefry4x32_crypto" class="def variant constructor anchored"><a href="#type-binop.Threefry4x32_crypto" class="anchor"></a><code><span>| </span><span><span class="constructor">Threefry4x32_crypto</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>4x32-bit Threefry PRNG, 20-round cryptographic version. Requires a 128-bit key and a 128-bit counter and outputs a 128-bit value (precision <code>Uint4x32</code>).</p><span class="comment-delim">*)</span></div></li><li id="type-binop.Threefry4x32_light" class="def variant constructor anchored"><a href="#type-binop.Threefry4x32_light" class="anchor"></a><code><span>| </span><span><span class="constructor">Threefry4x32_light</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>4x32-bit Threefry PRNG, 2-round light version (as in JAX/XLA). Requires a 128-bit key and a 128-bit counter and outputs a 128-bit value (precision <code>Uint4x32</code>).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binop_of_sexp"><a href="#val-binop_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> binop_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-binop">binop</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_binop"><a href="#val-sexp_of_binop" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_binop : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_binop"><a href="#val-compare_binop" class="anchor"></a><code><span><span class="keyword">val</span> compare_binop : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_binop"><a href="#val-equal_binop" class="anchor"></a><code><span><span class="keyword">val</span> equal_binop : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span><span class="keyword">type</span> unop</span><span> = </span></code><ol><li id="type-unop.Identity" class="def variant constructor anchored"><a href="#type-unop.Identity" class="anchor"></a><code><span>| </span><span><span class="constructor">Identity</span></span></code></li><li id="type-unop.Relu" class="def variant constructor anchored"><a href="#type-unop.Relu" class="anchor"></a><code><span>| </span><span><span class="constructor">Relu</span></span></code></li><li id="type-unop.Satur01" class="def variant constructor anchored"><a href="#type-unop.Satur01" class="anchor"></a><code><span>| </span><span><span class="constructor">Satur01</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Saturate (truncate) to within the interval <code>[0; 1]</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-unop.Exp" class="def variant constructor anchored"><a href="#type-unop.Exp" class="anchor"></a><code><span>| </span><span><span class="constructor">Exp</span></span></code></li><li id="type-unop.Log" class="def variant constructor anchored"><a href="#type-unop.Log" class="anchor"></a><code><span>| </span><span><span class="constructor">Log</span></span></code></li><li id="type-unop.Exp2" class="def variant constructor anchored"><a href="#type-unop.Exp2" class="anchor"></a><code><span>| </span><span><span class="constructor">Exp2</span></span></code></li><li id="type-unop.Log2" class="def variant constructor anchored"><a href="#type-unop.Log2" class="anchor"></a><code><span>| </span><span><span class="constructor">Log2</span></span></code></li><li id="type-unop.Sin" class="def variant constructor anchored"><a href="#type-unop.Sin" class="anchor"></a><code><span>| </span><span><span class="constructor">Sin</span></span></code></li><li id="type-unop.Cos" class="def variant constructor anchored"><a href="#type-unop.Cos" class="anchor"></a><code><span>| </span><span><span class="constructor">Cos</span></span></code></li><li id="type-unop.Sqrt" class="def variant constructor anchored"><a href="#type-unop.Sqrt" class="anchor"></a><code><span>| </span><span><span class="constructor">Sqrt</span></span></code></li><li id="type-unop.Recip" class="def variant constructor anchored"><a href="#type-unop.Recip" class="anchor"></a><code><span>| </span><span><span class="constructor">Recip</span></span></code></li><li id="type-unop.Recip_sqrt" class="def variant constructor anchored"><a href="#type-unop.Recip_sqrt" class="anchor"></a><code><span>| </span><span><span class="constructor">Recip_sqrt</span></span></code></li><li id="type-unop.Neg" class="def variant constructor anchored"><a href="#type-unop.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span></span></code></li><li id="type-unop.Tanh_approx" class="def variant constructor anchored"><a href="#type-unop.Tanh_approx" class="anchor"></a><code><span>| </span><span><span class="constructor">Tanh_approx</span></span></code></li><li id="type-unop.Not" class="def variant constructor anchored"><a href="#type-unop.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>0. -&gt; 1. | _ -&gt; 0.</p><span class="comment-delim">*)</span></div></li><li id="type-unop.Uint4x32_to_prec_uniform1" class="def variant constructor anchored"><a href="#type-unop.Uint4x32_to_prec_uniform1" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint4x32_to_prec_uniform1</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Non-vectorized variant of <code>Uint4x32_to_prec_uniform</code> that converts the given Uint4x32 to a single value of the output precision. Less bit-efficient but operates poitwise. For random bits, the result is uniform over the range of the precision for integer precisions, and over the range [0.0, 1.0) for floating point precisions.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unop_of_sexp"><a href="#val-unop_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> unop_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-unop">unop</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_unop"><a href="#val-sexp_of_unop" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_unop : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_unop"><a href="#val-compare_unop" class="anchor"></a><code><span><span class="keyword">val</span> compare_unop : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_unop"><a href="#val-equal_unop" class="anchor"></a><code><span><span class="keyword">val</span> equal_unop : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-vec_unop"><a href="#type-vec_unop" class="anchor"></a><code><span><span class="keyword">type</span> vec_unop</span><span> = </span></code><ol><li id="type-vec_unop.Uint4x32_to_prec_uniform" class="def variant constructor anchored"><a href="#type-vec_unop.Uint4x32_to_prec_uniform" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint4x32_to_prec_uniform</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Converts the given Uint4x32 to the precision of the output in a bit-efficient manner. For random bits, the result is uniform over the range of the precision for integer precisions, and over the range [0.0, 1.0) for floating point precisions. When used in an access pattern, the indices are converted to a byte offset depending on the given precision. NOTE: this operation, unlike any others, impacts projections and shape inference (one input cell corresponds to a few output cells).</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_unop_of_sexp"><a href="#val-vec_unop_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> vec_unop_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-vec_unop">vec_unop</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_vec_unop"><a href="#val-sexp_of_vec_unop" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_vec_unop : <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_vec_unop"><a href="#val-compare_vec_unop" class="anchor"></a><code><span><span class="keyword">val</span> compare_vec_unop : <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_vec_unop"><a href="#val-equal_vec_unop" class="anchor"></a><code><span><span class="keyword">val</span> equal_vec_unop : <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ternop"><a href="#type-ternop" class="anchor"></a><code><span><span class="keyword">type</span> ternop</span><span> = </span></code><ol><li id="type-ternop.Where" class="def variant constructor anchored"><a href="#type-ternop.Where" class="anchor"></a><code><span>| </span><span><span class="constructor">Where</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Where(a,b,c): if a then b else c</p><span class="comment-delim">*)</span></div></li><li id="type-ternop.FMA" class="def variant constructor anchored"><a href="#type-ternop.FMA" class="anchor"></a><code><span>| </span><span><span class="constructor">FMA</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>FMA(a,b,c): (a * b) + c, non-accumulating</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ternop_of_sexp"><a href="#val-ternop_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> ternop_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-ternop">ternop</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_ternop"><a href="#val-sexp_of_ternop" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_ternop : <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_ternop"><a href="#val-compare_ternop" class="anchor"></a><code><span><span class="keyword">val</span> compare_ternop : <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_ternop"><a href="#val-equal_ternop" class="anchor"></a><code><span><span class="keyword">val</span> equal_ternop : <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-op"><a href="#type-op" class="anchor"></a><code><span><span class="keyword">type</span> op</span><span> = </span></code><ol><li id="type-op.Ternop" class="def variant constructor anchored"><a href="#type-op.Ternop" class="anchor"></a><code><span>| </span><span><span class="constructor">Ternop</span> <span class="keyword">of</span> <a href="#type-ternop">ternop</a></span></code></li><li id="type-op.Binop" class="def variant constructor anchored"><a href="#type-op.Binop" class="anchor"></a><code><span>| </span><span><span class="constructor">Binop</span> <span class="keyword">of</span> <a href="#type-binop">binop</a></span></code></li><li id="type-op.Unop" class="def variant constructor anchored"><a href="#type-op.Unop" class="anchor"></a><code><span>| </span><span><span class="constructor">Unop</span> <span class="keyword">of</span> <a href="#type-unop">unop</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-op_of_sexp"><a href="#val-op_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> op_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-op">op</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_op"><a href="#val-sexp_of_op" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_op : <span><a href="#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_op"><a href="#val-compare_op" class="anchor"></a><code><span><span class="keyword">val</span> compare_op : <span><a href="#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_op"><a href="#val-equal_op" class="anchor"></a><code><span><span class="keyword">val</span> equal_op : <span><a href="#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-op">op</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neutral_elem"><a href="#val-neutral_elem" class="anchor"></a><code><span><span class="keyword">val</span> neutral_elem : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Float.t</span></code></div><div class="spec-doc"><p>Either the left-neutral or right-neutral element of the operation. Unspecified if the operation does not have a neutral element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interpret_binop"><a href="#val-interpret_binop" class="anchor"></a><code><span><span class="keyword">val</span> interpret_binop : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Float.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interpret_unop"><a href="#val-interpret_unop" class="anchor"></a><code><span><span class="keyword">val</span> interpret_unop : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Float.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interpret_ternop"><a href="#val-interpret_ternop" class="anchor"></a><code><span><span class="keyword">val</span> interpret_ternop : 
  <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.Float.t <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.Float.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_binop_infix"><a href="#val-is_binop_infix" class="anchor"></a><code><span><span class="keyword">val</span> is_binop_infix : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Note: currently the %cd syntax only supports infix binops as assignment ops.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_binop_nice_infix"><a href="#val-is_binop_nice_infix" class="anchor"></a><code><span><span class="keyword">val</span> is_binop_nice_infix : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binop_cd_syntax"><a href="#val-binop_cd_syntax" class="anchor"></a><code><span><span class="keyword">val</span> binop_cd_syntax : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binop_cd_fallback_syntax"><a href="#val-binop_cd_fallback_syntax" class="anchor"></a><code><span><span class="keyword">val</span> binop_cd_fallback_syntax : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>In the %cd syntax, we support uncurried notation for binary ops in addition to the infix notation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-binop_c_syntax"><a href="#val-binop_c_syntax" class="anchor"></a><code><span><span class="keyword">val</span> binop_c_syntax : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> string * string * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_assign_op"><a href="#val-is_assign_op" class="anchor"></a><code><span><span class="keyword">val</span> is_assign_op : <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assign_op_cd_syntax"><a href="#val-assign_op_cd_syntax" class="anchor"></a><code><span><span class="keyword">val</span> assign_op_cd_syntax : <span><span class="label">initialize_neutral</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unop_cd_syntax"><a href="#val-unop_cd_syntax" class="anchor"></a><code><span><span class="keyword">val</span> unop_cd_syntax : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Note: currently we do not support unary prefix symbols.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_unop_cd_syntax"><a href="#val-vec_unop_cd_syntax" class="anchor"></a><code><span><span class="keyword">val</span> vec_unop_cd_syntax : <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unop_c_syntax"><a href="#val-unop_c_syntax" class="anchor"></a><code><span><span class="keyword">val</span> unop_c_syntax : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_unop_c_syntax"><a href="#val-vec_unop_c_syntax" class="anchor"></a><code><span><span class="keyword">val</span> vec_unop_c_syntax : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ternop_cd_syntax"><a href="#val-ternop_cd_syntax" class="anchor"></a><code><span><span class="keyword">val</span> ternop_cd_syntax : <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>In the %cd syntax, we use uncurried notation for ternary ops.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ternop_c_syntax"><a href="#val-ternop_c_syntax" class="anchor"></a><code><span><span class="keyword">val</span> ternop_c_syntax : <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> string * string * string * string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-c_convert_precision"><a href="#val-c_convert_precision" class="anchor"></a><code><span><span class="keyword">val</span> c_convert_precision : <span><span class="label">from</span>:<a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">to_</span>:<a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t * string</span></code></div></div><h3 id="***-pointer-representation-***"><a href="#***-pointer-representation-***" class="anchor"></a>*** Pointer representation ***</h3><div class="odoc-spec"><div class="spec type anchored" id="type-voidptr"><a href="#type-voidptr" class="anchor"></a><code><span><span class="keyword">type</span> voidptr</span><span> = <span><span class="xref-unresolved">Base</span>.unit <span class="xref-unresolved">Ctypes</span>.ptr</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_voidptr"><a href="#val-sexp_of_voidptr" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_voidptr : <span><span>unit <span class="xref-unresolved">Ctypes_static</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_voidptr"><a href="#val-compare_voidptr" class="anchor"></a><code><span><span class="keyword">val</span> compare_voidptr : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Ctypes</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Ctypes</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_voidptr"><a href="#val-equal_voidptr" class="anchor"></a><code><span><span class="keyword">val</span> equal_voidptr : <span><a href="#type-voidptr">voidptr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-voidptr">voidptr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-c_rawptr_to_string"><a href="#val-c_rawptr_to_string" class="anchor"></a><code><span><span class="keyword">val</span> c_rawptr_to_string : <span><span class="xref-unresolved">Base</span>.nativeint <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rawptr_to_string_hum"><a href="#val-rawptr_to_string_hum" class="anchor"></a><code><span><span class="keyword">val</span> rawptr_to_string_hum : <span><span class="xref-unresolved">Base</span>.nativeint <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-c_ptr_to_string"><a href="#val-c_ptr_to_string" class="anchor"></a><code><span><span class="keyword">val</span> c_ptr_to_string : <span><span><span class="type-var">'elem</span> <span class="xref-unresolved">Ctypes</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ptr_to_string_hum"><a href="#val-ptr_to_string_hum" class="anchor"></a><code><span><span class="keyword">val</span> ptr_to_string_hum : <span><span><span class="type-var">'elem</span> <span class="xref-unresolved">Ctypes</span>.ptr</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prec">prec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.String.t</span></code></div></div><h3 id="***-external-ffi-declarations-***"><a href="#***-external-ffi-declarations-***" class="anchor"></a>*** External FFI declarations ***</h3><div class="odoc-spec"><div class="spec type anchored" id="type-axis_padding"><a href="#type-axis_padding" class="anchor"></a><code><span><span class="keyword">type</span> axis_padding</span><span> = </span><span>{</span></code><ol><li id="type-axis_padding.left" class="def record field anchored"><a href="#type-axis_padding.left" class="anchor"></a><code><span>left : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-axis_padding.right" class="def record field anchored"><a href="#type-axis_padding.right" class="anchor"></a><code><span>right : <span class="xref-unresolved">Base</span>.int;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_padding_of_sexp"><a href="#val-axis_padding_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> axis_padding_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-axis_padding">axis_padding</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_axis_padding"><a href="#val-sexp_of_axis_padding" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_axis_padding : <span><a href="#type-axis_padding">axis_padding</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_axis_padding"><a href="#val-equal_axis_padding" class="anchor"></a><code><span><span class="keyword">val</span> equal_axis_padding : <span><a href="#type-axis_padding">axis_padding</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-axis_padding">axis_padding</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-bfloat16_to_single"><a href="#val-bfloat16_to_single" class="anchor"></a><code><span><span class="keyword">val</span> bfloat16_to_single : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.float</span></code></div><div class="spec-doc"><p>Original conversion functions</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-single_to_bfloat16"><a href="#val-single_to_bfloat16" class="anchor"></a><code><span><span class="keyword">val</span> single_to_bfloat16 : <span><span class="xref-unresolved">Base</span>.float <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-half_to_single"><a href="#val-half_to_single" class="anchor"></a><code><span><span class="keyword">val</span> half_to_single : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.float</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-single_to_half"><a href="#val-single_to_half" class="anchor"></a><code><span><span class="keyword">val</span> single_to_half : <span><span class="xref-unresolved">Base</span>.float <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fp8_to_single"><a href="#val-fp8_to_single" class="anchor"></a><code><span><span class="keyword">val</span> fp8_to_single : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.float</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-single_to_fp8"><a href="#val-single_to_fp8" class="anchor"></a><code><span><span class="keyword">val</span> single_to_fp8 : <span><span class="xref-unresolved">Base</span>.float <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-copy_with_padding_c"><a href="#val-copy_with_padding_c" class="anchor"></a><code><span><span class="keyword">val</span> copy_with_padding_c : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Genarray.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span> <span class="xref-unresolved">Stdlib</span>.Bigarray.Genarray.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-axis_padding">axis_padding</a> <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-threefry4x32_crypto"><a href="#val-threefry4x32_crypto" class="anchor"></a><code><span><span class="keyword">val</span> threefry4x32_crypto : 
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Threefry4x32 PRNG - 20 round cryptographic version</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-threefry4x32_light"><a href="#val-threefry4x32_light" class="anchor"></a><code><span><span class="keyword">val</span> threefry4x32_light : 
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Threefry4x32 PRNG - 2 round light version</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-threefry4x32"><a href="#val-threefry4x32" class="anchor"></a><code><span><span class="keyword">val</span> threefry4x32 : 
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Threefry4x32 PRNG - default version</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_single_uniform"><a href="#val-uint4x32_to_single_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_single_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.float</span></code></div><div class="spec-doc"><p>Conversion from uint4x32 to various uniform distributions</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_double_uniform"><a href="#val-uint4x32_to_double_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_double_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.float</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_int32_uniform"><a href="#val-uint4x32_to_int32_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_int32_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_int64_uniform"><a href="#val-uint4x32_to_int64_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_int64_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int64</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_uint32_uniform"><a href="#val-uint4x32_to_uint32_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_uint32_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_uint64_uniform"><a href="#val-uint4x32_to_uint64_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_uint64_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int64</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_byte_uniform"><a href="#val-uint4x32_to_byte_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_byte_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_uint16_uniform"><a href="#val-uint4x32_to_uint16_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_uint16_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_bfloat16_uniform"><a href="#val-uint4x32_to_bfloat16_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_bfloat16_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_half_uniform"><a href="#val-uint4x32_to_half_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_half_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint4x32_to_fp8_uniform"><a href="#val-uint4x32_to_fp8_uniform" class="anchor"></a><code><span><span class="keyword">val</span> uint4x32_to_fp8_uniform : <span><span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-single_to_uint4x32"><a href="#val-single_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> single_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.float <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Conversion to uint4x32 from various types</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-double_to_uint4x32"><a href="#val-double_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> double_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.float <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-int32_to_uint4x32"><a href="#val-int32_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> int32_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-int64_to_uint4x32"><a href="#val-int64_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> int64_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int64 <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint32_to_uint4x32"><a href="#val-uint32_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> uint32_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint64_to_uint4x32"><a href="#val-uint64_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> uint64_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int64 <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-byte_to_uint4x32"><a href="#val-byte_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> byte_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-uint16_to_uint4x32"><a href="#val-uint16_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> uint16_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-bfloat16_to_uint4x32"><a href="#val-bfloat16_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> bfloat16_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-half_to_uint4x32"><a href="#val-half_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> half_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-fp8_to_uint4x32"><a href="#val-fp8_to_uint4x32" class="anchor"></a><code><span><span class="keyword">val</span> fp8_to_uint4x32 : <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><h3 id="***-precision-homogeneity-classification-***"><a href="#***-precision-homogeneity-classification-***" class="anchor"></a>*** Precision homogeneity classification ***</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_homogeneous_prec_unop"><a href="#val-is_homogeneous_prec_unop" class="anchor"></a><code><span><span class="keyword">val</span> is_homogeneous_prec_unop : <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the unary operation is homogeneous in precision, meaning its argument should be converted to the result precision.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_homogeneous_prec_vec_unop"><a href="#val-is_homogeneous_prec_vec_unop" class="anchor"></a><code><span><span class="keyword">val</span> is_homogeneous_prec_vec_unop : <span><a href="#type-vec_unop">vec_unop</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the vec_unop operation is homogeneous in precision, meaning its argument should be converted to the result precision.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_homogeneous_prec_binop"><a href="#val-is_homogeneous_prec_binop" class="anchor"></a><code><span><span class="keyword">val</span> is_homogeneous_prec_binop : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the binary operation is homogeneous in precision, meaning its arguments should be converted to the result precision.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_homogeneous_prec_ternop"><a href="#val-is_homogeneous_prec_ternop" class="anchor"></a><code><span><span class="keyword">val</span> is_homogeneous_prec_ternop : <span><a href="#type-ternop">ternop</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the ternary operation is homogeneous in precision, meaning its arguments should be converted to the result precision.</p></div></div></div></body></html>
