<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Shape (neural_nets_lib.Ocannl_tensor.Shape)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">neural_nets_lib</a> &#x00BB; <a href="../index.html">Ocannl_tensor</a> &#x00BB; Shape</nav><header class="odoc-preamble"><h1>Module <code><span>Ocannl_tensor.Shape</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#tensor-shape-types,-shape-inference,-projection-inference.">Tensor shape types, shape inference, projection inference.</a><ul><li><a href="#labels-specifications-and-einsum-notation.">Labels specifications and einsum notation.</a></li><li><a href="#user-ish-api.">User-ish API.</a></li><li><a href="#internal-ish-api.">Internal-ish API.</a></li></ul></li></ul></nav></div><div class="odoc-content"><h2 id="tensor-shape-types,-shape-inference,-projection-inference."><a href="#tensor-shape-types,-shape-inference,-projection-inference." class="anchor"></a>Tensor shape types, shape inference, projection inference.</h2><h3 id="labels-specifications-and-einsum-notation."><a href="#labels-specifications-and-einsum-notation." class="anchor"></a>Labels specifications and einsum notation.</h3><p>Definition and properties of the syntax of labels specifications and einsum notation:</p><ul><li>Whitespace-insensitive except that whitespace separates identifiers.</li><li>Comes in two variants: single-character and multicharacter;</li><li>if there is a comma <code>','</code> anywhere in the initial text, the multicharacter version is used,</li><li>otherwise the single character version is used.</li><li>Currently, the only non-whitespace, non-alphanumeric characters that make sense / are allowed in a spec are: <code>'&gt;', '|', '-', ',', '=', ';', '+', '*', '_'</code>.</li><li>identifier: single alphanum character or '_' in single-char mode, a sequence of alphanum characters or '_' otherwise (whitespace not allowed).</li><li>separators: a sequence of commas and whitespaces.</li><li>separators_with_comma: commas and whitespaces containing at least one comma.</li><li>axes_spec_single_char: separators? identifier+ separators?</li><li>axes_spec_multichar: separators? (identifier separators_with_comma)* identifier separators?</li><li>conv_expression: term '+' term</li><li>term: (coeff '*')? identifier</li><li>coeff: integer -- note that syntax extensions will splice in the value of an OCaml identifier</li><li>ellipsis_spec: '...' &lt;|&gt; '..' identifier '..'</li><li>row_spec: axes_spec &lt;|&gt; ellipsis_spec axes_spec &lt;|&gt; axes_spec ellipsis_spec axes_spec</li><li>labels_spec: row_spec &lt;|&gt; row_spec '|' row_spec &lt;|&gt; row_spec '-&gt;' row_spec &lt;|&gt; row_spec '|' row_spec '-&gt;' row_spec.</li><li>permute_spec: labels_spec '=&gt;' labels_spec</li><li>einsum_spec: labels_spec ';' labels_spec '=&gt;' labels_spec</li></ul><p>If labels_spec does not contain <code>&quot;|&quot;</code> nor <code>&quot;-&gt;&quot;</code>, each label is of the kind <code>Output</code>. If the spec doesn't contain <code>&quot;|&quot;</code>, labels to the left of <code>&quot;-&gt;&quot;</code> are <code>Input</code> and to the right <code>Output</code>. Labels to the left of <code>&quot;|&quot;</code> are <code>Batch</code>, and between <code>&quot;|&quot;</code> and <code>&quot;-&gt;&quot;</code> are <code>Input</code>.</p><p>The labels <code>&quot;..&quot;ident&quot;..&quot;</code>, <code>&quot;...&quot;</code> (where <code>ident</code> does not contain any of the special characters) are only allowed once for a kind. They are used to enable (in-the-middle) broadcasting for the axis kind in the einsum-related shape inference (like the ellipsis <code>&quot;...&quot;</code> in <code>numpy.einsum</code>), and are translated to row variables. The ellipsis <code>&quot;...&quot;</code> is context dependent: in the batch row it is the same as <code>&quot;..batch..&quot;</code>, in the input row the same as <code>&quot;..input..&quot;</code>, in the output row the same as <code>&quot;..output..&quot;</code>. When the same row variable is used in multiple rows, the corresponding broadcasted axes are matched pointwise in the resulting operation.</p><p>The label <code>&quot;_&quot;</code> is a place-holder: it is not output to the resulting map but aligns the axes of other labels.</p><p>Conv expressions have the form <code>stride*output+dilation*kernel</code> where stride and dilation are optional integer coefficients (defaulting to 1), and output/kernel are axis labels. This syntax enables convolution-style indexing where input_dimension = stride * output_iterator + dilation * kernel_iterator. Conv expressions automatically trigger multichar mode and are only supported in multichar mode.</p><p>Note: currently, OCANNL shapes always allow broadcasting. Row variables track the broadcasted axes -- if there is no row variable, broadcasted axes are not tracked. In the notation case `row_spec` = `axes_spec`, the axes are the rightmost axes (broadcasting to the left). In the past, we supported preventing broadcasting, but removed that to reduce complexity.</p><h3 id="user-ish-api."><a href="#user-ish-api." class="anchor"></a>User-ish API.</h3><div class="odoc-spec"><div class="spec type anchored" id="type-padding"><a href="#type-padding" class="anchor"></a><code><span><span class="keyword">type</span> padding</span><span> = <span><span><a href="../Row/index.html#type-axis_padding">Row.axis_padding</a> <span class="xref-unresolved">Base</span>.array</span> <span class="xref-unresolved">Base</span>.option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_padding"><a href="#val-sexp_of_padding" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_padding : <span><a href="#type-padding">padding</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-padding_of_sexp"><a href="#val-padding_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> padding_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-padding">padding</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_padding"><a href="#val-equal_padding" class="anchor"></a><code><span><span class="keyword">val</span> equal_padding : <span><a href="#type-padding">padding</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-padding">padding</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-axis_spec"><a href="#type-axis_spec" class="anchor"></a><code><span><span class="keyword">type</span> axis_spec</span><span> = </span></code><ol><li id="type-axis_spec.Label" class="def variant constructor anchored"><a href="#type-axis_spec.Label" class="anchor"></a><code><span>| </span><span><span class="constructor">Label</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A variable axis label.</p><span class="comment-delim">*)</span></div></li><li id="type-axis_spec.Fixed_index" class="def variant constructor anchored"><a href="#type-axis_spec.Fixed_index" class="anchor"></a><code><span>| </span><span><span class="constructor">Fixed_index</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A fixed index, used for projection.</p><span class="comment-delim">*)</span></div></li><li id="type-axis_spec.Conv_spec" class="def variant constructor anchored"><a href="#type-axis_spec.Conv_spec" class="anchor"></a><code><span>| </span><span><span class="constructor">Conv_spec</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-axis_spec.stride" class="def record field anchored"><a href="#type-axis_spec.stride" class="anchor"></a><code><span>stride : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-axis_spec.output_label" class="def record field anchored"><a href="#type-axis_spec.output_label" class="anchor"></a><code><span>output_label : <span class="xref-unresolved">Base</span>.string;</span></code></li><li id="type-axis_spec.dilation" class="def record field anchored"><a href="#type-axis_spec.dilation" class="anchor"></a><code><span>dilation : <span class="xref-unresolved">Base</span>.int;</span></code></li><li id="type-axis_spec.kernel_label" class="def record field anchored"><a href="#type-axis_spec.kernel_label" class="anchor"></a><code><span>kernel_label : <span class="xref-unresolved">Base</span>.string;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Convolution-style axis specification: stride*output + dilation*kernel.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Specification for individual axes in the einsum notation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_axis_spec"><a href="#val-compare_axis_spec" class="anchor"></a><code><span><span class="keyword">val</span> compare_axis_spec : <span><a href="#type-axis_spec">axis_spec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-axis_spec">axis_spec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_axis_spec"><a href="#val-sexp_of_axis_spec" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_axis_spec : <span><a href="#type-axis_spec">axis_spec</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_spec_of_sexp"><a href="#val-axis_spec_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> axis_spec_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-axis_spec">axis_spec</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.batch" class="def record field anchored"><a href="#type-t.batch" class="anchor"></a><code><span><span class="keyword">mutable</span> batch : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.input" class="def record field anchored"><a href="#type-t.input" class="anchor"></a><code><span><span class="keyword">mutable</span> input : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.output" class="def record field anchored"><a href="#type-t.output" class="anchor"></a><code><span><span class="keyword">mutable</span> output : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.batch_padding" class="def record field anchored"><a href="#type-t.batch_padding" class="anchor"></a><code><span><span class="keyword">mutable</span> batch_padding : <a href="#type-padding">padding</a>;</span></code></li><li id="type-t.input_padding" class="def record field anchored"><a href="#type-t.input_padding" class="anchor"></a><code><span><span class="keyword">mutable</span> input_padding : <a href="#type-padding">padding</a>;</span></code></li><li id="type-t.output_padding" class="def record field anchored"><a href="#type-t.output_padding" class="anchor"></a><code><span><span class="keyword">mutable</span> output_padding : <a href="#type-padding">padding</a>;</span></code></li><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : <span class="xref-unresolved">Base</span>.int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A node that has the same shape as this shape, or <code>-1</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.debug_name" class="def record field anchored"><a href="#type-t.debug_name" class="anchor"></a><code><span>debug_name : <span class="xref-unresolved">Base</span>.string;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Ppx_compare_lib</span>.Equal.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="xref-unresolved">Base__Ppx_compare_lib</span>.equal</span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Sexplib0</span>.Sexpable.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><span class="xref-unresolved">Sexplib0__</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0__</span>.Sexp.t</span></code></div></div></details></div><div class="odoc-spec"><div class="spec type anchored" id="type-deduce_within_shape"><a href="#type-deduce_within_shape" class="anchor"></a><code><span><span class="keyword">type</span> deduce_within_shape</span><span> = </span></code><ol><li id="type-deduce_within_shape.Not_constrained" class="def variant constructor anchored"><a href="#type-deduce_within_shape.Not_constrained" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_constrained</span></span></code></li><li id="type-deduce_within_shape.Input_equals_output" class="def variant constructor anchored"><a href="#type-deduce_within_shape.Input_equals_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Input_equals_output</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_deduce_within_shape"><a href="#val-compare_deduce_within_shape" class="anchor"></a><code><span><span class="keyword">val</span> compare_deduce_within_shape : 
  <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_deduce_within_shape"><a href="#val-sexp_of_deduce_within_shape" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_deduce_within_shape : <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deduce_within_shape_of_sexp"><a href="#val-deduce_within_shape_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> deduce_within_shape_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-deduce_within_shape">deduce_within_shape</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-delayed_var_ref"><a href="#type-delayed_var_ref" class="anchor"></a><code><span><span class="keyword">type</span> delayed_var_ref</span><span> = </span><span>{</span></code><ol><li id="type-delayed_var_ref.var_ref" class="def record field anchored"><a href="#type-delayed_var_ref.var_ref" class="anchor"></a><code><span>var_ref : <a href="../../../arrayjit/Ir/Indexing/index.html#type-variable_ref">Ir.Indexing.variable_ref</a>;</span></code></li><li id="type-delayed_var_ref.var" class="def record field anchored"><a href="#type-delayed_var_ref.var" class="anchor"></a><code><span><span class="keyword">mutable</span> var : <span>[ <span>`Row of <a href="../Row/index.html#type-row_var">Row.row_var</a></span> <span><span>| `Dim</span> of <a href="../Row/index.html#type-dim_var">Row.dim_var</a></span> <span>| `Not_set_yet</span> ]</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_delayed_var_ref"><a href="#val-equal_delayed_var_ref" class="anchor"></a><code><span><span class="keyword">val</span> equal_delayed_var_ref : <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_delayed_var_ref"><a href="#val-sexp_of_delayed_var_ref" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_delayed_var_ref : <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_variable_ref"><a href="#val-get_variable_ref" class="anchor"></a><code><span><span class="keyword">val</span> get_variable_ref : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="#type-delayed_var_ref">delayed_var_ref</a></span></code></div><div class="spec-doc"><p>Returns a fully unset variable reference with the given label.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_dim"><a href="#val-set_dim" class="anchor"></a><code><span><span class="keyword">val</span> set_dim : <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Sets the dimension resp. total elements of the dim resp. row variable reference to the given value. This will propagate through shape inference.</p><p>For row variables, this means the product of the dimensions, via the <code>Total_elems</code> constraint.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_equal"><a href="#val-set_equal" class="anchor"></a><code><span><span class="keyword">val</span> set_equal : <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Sets the two variable references to be equal (in some sense). This will propagate through shape inference.</p><p>When both references are dimension variables or both are row variables, this means they are precisely equal. When one is a dimension variable and the other is a row variable, this means they have the same number of total elements.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-compose_type"><a href="#type-compose_type" class="anchor"></a><code><span><span class="keyword">type</span> compose_type</span><span> = </span></code><ol><li id="type-compose_type.Pointwise_bin" class="def variant constructor anchored"><a href="#type-compose_type.Pointwise_bin" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointwise_bin</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>NumPy-style broadcast matching batch, input and output axes, e.g. as in <code>s1 + s2</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-compose_type.Compose" class="def variant constructor anchored"><a href="#type-compose_type.Compose" class="anchor"></a><code><span>| </span><span><span class="constructor">Compose</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Compose the outputs of the second shape with the inputs of the first shape, i.e. the shape of <code>fun x -&gt; s1(s2(x))</code>, or <code>s1 * s2</code> where <code>*</code> is the inner product (e.g. matrix multiply).</p><span class="comment-delim">*)</span></div></li><li id="type-compose_type.Einsum" class="def variant constructor anchored"><a href="#type-compose_type.Einsum" class="anchor"></a><code><span>| </span><span><span class="constructor">Einsum</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.string * <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="xref-unresolved">Base</span>.list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The binary &quot;einsum&quot; syntax: RHS1;RHS2=&gt;LHS, where RHSi, LHS are labels specifications. Since OCANNL's extended einsum notation supports both axis variables and row variables, it makes other compose types redundant. The <code>axis_labels</code> use pseudo-labels local to the notation, to line up the axes and row variables. The symmetric difference / disjunctive union of RHS1 and RHS2's pseudo-labels should be equal to LHS pseudo-labels.</p><p>The optional <a href="../../../arrayjit/Ir/Indexing/index.html#type-variable_ref"><code>Ir.Indexing.variable_ref</code></a>s will capture the solutions of the dimensions corresponding to the specification labels equal to <code>ref_label</code> of a reference.</p><p>Note: The &quot;right-hand-side&quot; is on the left! I.e. the syntax is &quot;rhs=&gt;lhs&quot;, &quot;rhs1;rhs2=&gt;lhs&quot;.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_compose_type"><a href="#val-sexp_of_compose_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_compose_type : <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_compose_type"><a href="#val-equal_compose_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_compose_type : <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-transpose_type"><a href="#type-transpose_type" class="anchor"></a><code><span><span class="keyword">type</span> transpose_type</span><span> = </span></code><ol><li id="type-transpose_type.Transpose" class="def variant constructor anchored"><a href="#type-transpose_type.Transpose" class="anchor"></a><code><span>| </span><span><span class="constructor">Transpose</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Swaps inputs and outputs of a shape, preserves batch axes.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Pointwise_un" class="def variant constructor anchored"><a href="#type-transpose_type.Pointwise_un" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointwise_un</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Preserves the shape.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Permute" class="def variant constructor anchored"><a href="#type-transpose_type.Permute" class="anchor"></a><code><span>| </span><span><span class="constructor">Permute</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.string * <span><a href="#type-delayed_var_ref">delayed_var_ref</a> <span class="xref-unresolved">Base</span>.list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The unary &quot;einsum&quot; syntax: RHS1=&gt;LHS.</p><p>The optional <a href="../../../arrayjit/Ir/Indexing/index.html#type-variable_ref"><code>Ir.Indexing.variable_ref</code></a>s will capture the solutions of the dimensions corresponding to the specification labels equal to <code>ref_label</code> of a reference.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Batch_slice" class="def variant constructor anchored"><a href="#type-transpose_type.Batch_slice" class="anchor"></a><code><span>| </span><span><span class="constructor">Batch_slice</span> <span class="keyword">of</span> <a href="../../../arrayjit/Ir/Indexing/index.html#type-static_symbol">Ir.Indexing.static_symbol</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Removes the leftmost batch axis.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Uint4x32_to_prec" class="def variant constructor anchored"><a href="#type-transpose_type.Uint4x32_to_prec" class="anchor"></a><code><span>| </span><span><span class="constructor">Uint4x32_to_prec</span> <span class="keyword">of</span> <span><a href="../../../arrayjit/Ir/Ops/index.html#type-prec">Ir.Ops.prec</a> <span class="xref-unresolved">Base</span>.Lazy.t</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Converts precision in a bit-effient way, with a corresponding conversion in total number of elements. Currently, assumes the incoming tensor (RHS) has just a single axis to not force unnecessary minimum sizes on output axes.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_transpose_type"><a href="#val-equal_transpose_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_transpose_type : <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_transpose_type"><a href="#val-sexp_of_transpose_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_transpose_type : <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ternary_type"><a href="#type-ternary_type" class="anchor"></a><code><span><span class="keyword">type</span> ternary_type</span><span> = </span></code><ol><li id="type-ternary_type.Pointwise_tern" class="def variant constructor anchored"><a href="#type-ternary_type.Pointwise_tern" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointwise_tern</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>As in the operation <code>Where</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-ternary_type.Compose_accumulate" class="def variant constructor anchored"><a href="#type-ternary_type.Compose_accumulate" class="anchor"></a><code><span>| </span><span><span class="constructor">Compose_accumulate</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>As in the operation <code>FMA</code>.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>If you miss expressivity here, leave a note on <a href="https://github.com/ahrefs/ocannl/issues/305">issue 305</a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_ternary_type"><a href="#val-equal_ternary_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_ternary_type : <span><a href="#type-ternary_type">ternary_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ternary_type">ternary_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_ternary_type"><a href="#val-sexp_of_ternary_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_ternary_type : <span><a href="#type-ternary_type">ternary_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-terminal_type"><a href="#type-terminal_type" class="anchor"></a><code><span><span class="keyword">type</span> terminal_type</span><span> = </span></code><ol><li id="type-terminal_type.Data" class="def variant constructor anchored"><a href="#type-terminal_type.Data" class="anchor"></a><code><span>| </span><span><span class="constructor">Data</span> <span class="keyword">of</span> <a href="../../../arrayjit/Ir/Assignments/index.html#type-init_data">Ir.Assignments.init_data</a></span></code></li><li id="type-terminal_type.Fetch" class="def variant constructor anchored"><a href="#type-terminal_type.Fetch" class="anchor"></a><code><span>| </span><span><span class="constructor">Fetch</span> <span class="keyword">of</span> <a href="../../../arrayjit/Ir/Assignments/index.html#type-fetch_op">Ir.Assignments.fetch_op</a></span></code></li></ol></div><div class="spec-doc"><p>Extracts any available shape information from the initialization or fetch.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_terminal_type"><a href="#val-equal_terminal_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_terminal_type : <span><a href="#type-terminal_type">terminal_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-terminal_type">terminal_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_terminal_type"><a href="#val-sexp_of_terminal_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_terminal_type : <span><a href="#type-terminal_type">terminal_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?batch_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?input_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?output_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?batch_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?input_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?output_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?deduced</span>:<a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">debug_name</span>:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Creates a shape. <code>id</code> should be the id the associated tensor (if any). At most one of the pairs <code>batch_dims</code>, <code>batch_axes</code> etc. should be given: if none, the corresponding row will be inferred. <code>batch_axes</code> etc. provide labels for the dimensions of the corresponding axes. Note that these are dimensions labels and not axis labels: they need not be unique for a row, are inferred when provided, and must match whenever the axis sizes must match.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string_hum"><a href="#val-to_string_hum" class="anchor"></a><code><span><span class="keyword">val</span> to_string_hum : <span><span class="optlabel">?style</span>:<a href="../Row/index.html#type-print_style">Row.print_style</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsafe_reinitialize"><a href="#val-unsafe_reinitialize" class="anchor"></a><code><span><span class="keyword">val</span> unsafe_reinitialize : <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Bring global state to its initialization values. This invalidates any unfinished inference.</p></div></div><h3 id="internal-ish-api."><a href="#internal-ish-api." class="anchor"></a>Internal-ish API.</h3><div class="odoc-spec"><div class="spec value anchored" id="val-set_terminal"><a href="#val-set_terminal" class="anchor"></a><code><span><span class="keyword">val</span> set_terminal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Mark the shape as terminal, so that its rows can be closed to Least Upper Bounds (LUBs). This function is only intended for parameters shapes, which would otherwise not be terminal because of the initialization expressions of the parameters.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-logic"><a href="#type-logic" class="anchor"></a><code><span><span class="keyword">type</span> logic</span><span> = </span></code><ol><li id="type-logic.Broadcast" class="def variant constructor anchored"><a href="#type-logic.Broadcast" class="anchor"></a><code><span>| </span><span><span class="constructor">Broadcast</span> <span class="keyword">of</span> <a href="#type-compose_type">compose_type</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Matches the shapes for a binary operation.</p><p>For <code>Broadcast (Einsum (ls1, ls2, ls3), s1, s2)</code>, the labels of <code>s1</code> and <code>s2</code> must match according to the <code>ls1</code>, <code>ls2</code> lineup, and the resulting shape inherits the labels according to the <code>ls3</code> lineup.</p><span class="comment-delim">*)</span></div></li><li id="type-logic.Transpose" class="def variant constructor anchored"><a href="#type-logic.Transpose" class="anchor"></a><code><span>| </span><span><span class="constructor">Transpose</span> <span class="keyword">of</span> <a href="#type-transpose_type">transpose_type</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Permutes the axes of a shape. One case of <code>Transpose</code> is to swap inputs with outputs of <code>s1</code>, hence the name.</p><span class="comment-delim">*)</span></div></li><li id="type-logic.Broadcast_tern" class="def variant constructor anchored"><a href="#type-logic.Broadcast_tern" class="anchor"></a><code><span>| </span><span><span class="constructor">Broadcast_tern</span> <span class="keyword">of</span> <a href="#type-ternary_type">ternary_type</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Matches the shapes for a ternary operation.</p><span class="comment-delim">*)</span></div></li><li id="type-logic.Terminal" class="def variant constructor anchored"><a href="#type-logic.Terminal" class="anchor"></a><code><span>| </span><span><span class="constructor">Terminal</span> <span class="keyword">of</span> <a href="#type-terminal_type">terminal_type</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Extracts any available shape information from the initialization.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>How to propagate shape updates and do the last update of <code>Tensor.t.shape</code> when finalizing the tensor. Axes are broadcast-expanded on a bottom-up update to fit the incoming shape.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_logic"><a href="#val-equal_logic" class="anchor"></a><code><span><span class="keyword">val</span> equal_logic : <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_logic"><a href="#val-sexp_of_logic" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_logic : <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-update_id"><a href="#type-update_id" class="anchor"></a><code><span><span class="keyword">type</span> update_id</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_update_id"><a href="#val-equal_update_id" class="anchor"></a><code><span><span class="keyword">val</span> equal_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_update_id"><a href="#val-compare_update_id" class="anchor"></a><code><span><span class="keyword">val</span> compare_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_fold_update_id"><a href="#val-hash_fold_update_id" class="anchor"></a><code><span><span class="keyword">val</span> hash_fold_update_id : 
  <span><span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_update_id"><a href="#val-hash_update_id" class="anchor"></a><code><span><span class="keyword">val</span> hash_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.hash_value</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_update_id"><a href="#val-sexp_of_update_id" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_id_of_sexp"><a href="#val-update_id_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> update_id_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-update_id">update_id</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_update_id"><a href="#val-get_update_id" class="anchor"></a><code><span><span class="keyword">val</span> get_update_id : <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-update_id">update_id</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logic_to_spec"><a href="#val-logic_to_spec" class="anchor"></a><code><span><span class="keyword">val</span> logic_to_spec : <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.string</span></code></div><div class="spec-doc"><p>Converts a shape logic to its string specification for debugging/display purposes.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-update_step"><a href="#type-update_step" class="anchor"></a><code><span><span class="keyword">type</span> update_step</span><span> = </span><span>{</span></code><ol><li id="type-update_step.shape" class="def record field anchored"><a href="#type-update_step.shape" class="anchor"></a><code><span>shape : <a href="#type-t">t</a>;</span></code></li><li id="type-update_step.logic" class="def record field anchored"><a href="#type-update_step.logic" class="anchor"></a><code><span>logic : <a href="#type-logic">logic</a>;</span></code></li><li id="type-update_step.id" class="def record field anchored"><a href="#type-update_step.id" class="anchor"></a><code><span>id : <a href="#type-update_id">update_id</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Data required for a shape inference update step. Ideally, an update should be performed at least twice, the second time after all the other relevant updates have been performed for the first time. In OCANNL, this is achieved by performing updates both as the tensors are constructed, and via lazy callbacks as the corresponding <code>Ir.Indexing</code> dimensions and projections are first accessed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_update_step"><a href="#val-sexp_of_update_step" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_update_step : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_dims"><a href="#val-to_dims" class="anchor"></a><code><span><span class="keyword">val</span> to_dims : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Uses the matrix convention of putting the input axes last.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_padding"><a href="#val-to_padding" class="anchor"></a><code><span><span class="keyword">val</span> to_padding : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../../arrayjit/Ir/Ops/index.html#type-axis_padding">Ir.Ops.axis_padding</a> <span class="xref-unresolved">Base</span>.array</span> * <span class="xref-unresolved">Base</span>.float)</span> <span class="xref-unresolved">Base</span>.option</span></span></code></div><div class="spec-doc"><p>Returns the padding of the shape, if any. Includes the padded value. Uses the matrix convention of putting the input axes last.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-propagate_shapes"><a href="#val-propagate_shapes" class="anchor"></a><code><span><span class="keyword">val</span> propagate_shapes : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-derive_projections"><a href="#val-derive_projections" class="anchor"></a><code><span><span class="keyword">val</span> derive_projections : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../arrayjit/Ir/Indexing/index.html#type-projections">Ir.Indexing.projections</a></span></code></div><div class="spec-doc"><p>Computes the indexing into subtensors given the shape information of a tensor. <code>derive_projections</code> should only be invoked when the shapes are fully inferred already!</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_spec"><a href="#val-of_spec" class="anchor"></a><code><span><span class="keyword">val</span> of_spec : 
  <span><span class="optlabel">?deduced</span>:<a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">debug_name</span>:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-default_display_indices"><a href="#val-default_display_indices" class="anchor"></a><code><span><span class="keyword">val</span> default_display_indices : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_labels"><a href="#val-to_labels" class="anchor"></a><code><span><span class="keyword">val</span> to_labels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.array</span></span></code></div><div class="spec-doc"><p>Uses the matrix convention of putting the input axes last.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-axis_map"><a href="#type-axis_map" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a axis_map</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-parsed_axis_labels"><a href="#type-parsed_axis_labels" class="anchor"></a><code><span><span class="keyword">type</span> parsed_axis_labels</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_parsed_axis_labels"><a href="#val-sexp_of_parsed_axis_labels" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_parsed_axis_labels : <span><a href="#type-parsed_axis_labels">parsed_axis_labels</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parsed_axis_labels_of_sexp"><a href="#val-parsed_axis_labels_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> parsed_axis_labels_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-parsed_axis_labels">parsed_axis_labels</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_labels"><a href="#val-axis_labels" class="anchor"></a><code><span><span class="keyword">val</span> axis_labels : <span><a href="#type-parsed_axis_labels">parsed_axis_labels</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-axis_spec">axis_spec</a> <a href="#type-axis_map">axis_map</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_labels_of_spec"><a href="#val-axis_labels_of_spec" class="anchor"></a><code><span><span class="keyword">val</span> axis_labels_of_spec : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="#type-parsed_axis_labels">parsed_axis_labels</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_map_to_dims_index"><a href="#val-axis_map_to_dims_index" class="anchor"></a><code><span><span class="keyword">val</span> axis_map_to_dims_index : <span><span class="optlabel">?default</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-axis_map">axis_map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Base</span>.array</span></span></code></div></div></div></body></html>
