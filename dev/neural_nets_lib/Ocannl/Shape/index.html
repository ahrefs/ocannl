<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Shape (neural_nets_lib.Ocannl.Shape)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">neural_nets_lib</a> &#x00BB; <a href="../index.html">Ocannl</a> &#x00BB; Shape</nav><header class="odoc-preamble"><h1>Module <code><span>Ocannl.Shape</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#tensor-shape-types,-shape-inference,-projection-inference.">Tensor shape types, shape inference, projection inference.</a><ul><li><a href="#labels-specifications-and-einsum-notation.">Labels specifications and einsum notation.</a></li><li><a href="#user-ish-api.">User-ish API.</a></li><li><a href="#internal-ish-api.">Internal-ish API.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="tensor-shape-types,-shape-inference,-projection-inference."><a href="#tensor-shape-types,-shape-inference,-projection-inference." class="anchor"></a>Tensor shape types, shape inference, projection inference.</h2><h3 id="labels-specifications-and-einsum-notation."><a href="#labels-specifications-and-einsum-notation." class="anchor"></a>Labels specifications and einsum notation.</h3><p>Definition and properties of the syntax of labels specifications and einsum notation:</p><ul><li>Whitespace-insensitive except that whitespace separates identifiers.</li><li>Comes in two variants: single-character and multicharacter;</li><li>if there is a comma <code>','</code> anywhere in the initial text, the multicharacter version is used,</li><li>otherwise the single character version is used.</li><li>Currently, the only non-whitespace, non-alphanumeric characters that make sense / are allowed in a spec are: <code>'&gt;', '|', '-', ',', '=', ';'</code>.</li><li>identifier: single alphanum character or '_' in single-char mode, a sequence of alphanum characters or '_' otherwise (whitespace not allowed).</li><li>separators: a sequence of commas and whitespaces.</li><li>separators_with_comma: commas and whitespaces containing at least one comma.</li><li>axes_spec_single_char: separators? identifier+ separators?</li><li>axes_spec_multichar: separators? (identifier separators_with_comma)* identifier separators?</li><li>ellipsis_spec: '...' &lt;|&gt; '..' identifier '..'</li><li>row_spec: axes_spec &lt;|&gt; ellipsis_spec axes_spec &lt;|&gt; axes_spec ellipsis_spec axes_spec</li><li>labels_spec: row_spec &lt;|&gt; row_spec '|' row_spec &lt;|&gt; row_spec '-&gt;' row_spec &lt;|&gt; row_spec '|' row_spec '-&gt;' row_spec.</li><li>permute_spec: labels_spec '=&gt;' labels_spec</li><li>einsum_spec: labels_spec ';' labels_spec '=&gt;' labels_spec</li></ul><p>If labels_spec does not contain <code>&quot;|&quot;</code> nor <code>&quot;-&gt;&quot;</code>, each label is of the kind <code>Output</code>. If the spec doesn't contain <code>&quot;|&quot;</code>, labels to the left of <code>&quot;-&gt;&quot;</code> are <code>Input</code> and to the right <code>Output</code>. Labels to the left of <code>&quot;|&quot;</code> are <code>Batch</code>, and between <code>&quot;|&quot;</code> and <code>&quot;-&gt;&quot;</code> are <code>Input</code>.</p><p>The labels <code>&quot;..&quot;ident&quot;..&quot;</code>, <code>&quot;...&quot;</code> (where <code>ident</code> does not contain any of the special characters) are only allowed once for a kind. They are used to enable (in-the-middle) broadcasting for the axis kind in the einsum-related shape inference (like the ellipsis <code>&quot;...&quot;</code> in <code>numpy.einsum</code>), and are translated to row variables. The ellipsis <code>&quot;...&quot;</code> is context dependent: in the batch row it is the same as <code>&quot;..batch..&quot;</code>, in the input row the same as <code>&quot;..input..&quot;</code>, in the output row the same as <code>&quot;..output..&quot;</code>. When the same row variable is used in multiple rows, the corresponding broadcasted axes are matched pointwise in the resulting operation.</p><p>The label <code>&quot;_&quot;</code> is a place-holder: it is not output to the resulting map but aligns the axes of other labels.</p><h3 id="user-ish-api."><a href="#user-ish-api." class="anchor"></a>User-ish API.</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.batch" class="def record field anchored"><a href="#type-t.batch" class="anchor"></a><code><span><span class="keyword">mutable</span> batch : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.input" class="def record field anchored"><a href="#type-t.input" class="anchor"></a><code><span><span class="keyword">mutable</span> input : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.output" class="def record field anchored"><a href="#type-t.output" class="anchor"></a><code><span><span class="keyword">mutable</span> output : <a href="../Row/index.html#type-t">Row.t</a>;</span></code></li><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : <span class="xref-unresolved">Base</span>.int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A node that has the same shape as this shape.</p><span class="comment-delim">*)</span></div></li><li id="type-t.debug_name" class="def record field anchored"><a href="#type-t.debug_name" class="anchor"></a><code><span>debug_name : <span class="xref-unresolved">Base</span>.string;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Ppx_compare_lib</span>.Equal.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="xref-unresolved">Base__Ppx_compare_lib</span>.equal</span></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">Sexplib0</span>.Sexpable.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">t</span> := <span class="xref-unresolved">t</span></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> t_of_sexp : <span><span class="xref-unresolved">Sexplib0__</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0__</span>.Sexp.t</span></code></div></div></details></div><div class="odoc-spec"><div class="spec type anchored" id="type-deduce_within_shape"><a href="#type-deduce_within_shape" class="anchor"></a><code><span><span class="keyword">type</span> deduce_within_shape</span><span> = </span></code><ol><li id="type-deduce_within_shape.Not_constrained" class="def variant constructor anchored"><a href="#type-deduce_within_shape.Not_constrained" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_constrained</span></span></code></li><li id="type-deduce_within_shape.Input_equals_output" class="def variant constructor anchored"><a href="#type-deduce_within_shape.Input_equals_output" class="anchor"></a><code><span>| </span><span><span class="constructor">Input_equals_output</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_deduce_within_shape"><a href="#val-compare_deduce_within_shape" class="anchor"></a><code><span><span class="keyword">val</span> compare_deduce_within_shape : 
  <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_deduce_within_shape"><a href="#val-sexp_of_deduce_within_shape" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_deduce_within_shape : <span><a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deduce_within_shape_of_sexp"><a href="#val-deduce_within_shape_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> deduce_within_shape_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-deduce_within_shape">deduce_within_shape</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-compose_type"><a href="#type-compose_type" class="anchor"></a><code><span><span class="keyword">type</span> compose_type</span><span> = </span></code><ol><li id="type-compose_type.Pointwise_bin" class="def variant constructor anchored"><a href="#type-compose_type.Pointwise_bin" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointwise_bin</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>NumPy-style broadcast matching batch, input and output axes, e.g. as in <code>s1 + s2</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-compose_type.Compose" class="def variant constructor anchored"><a href="#type-compose_type.Compose" class="anchor"></a><code><span>| </span><span><span class="constructor">Compose</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Compose the outputs of the second shape with the inputs of the first shape, i.e. the shape of <code>fun x -&gt; s1(s2(x))</code>, or <code>s1 * s2</code> where <code>*</code> is the inner product (e.g. matrix multiply).</p><span class="comment-delim">*)</span></div></li><li id="type-compose_type.Einsum" class="def variant constructor anchored"><a href="#type-compose_type.Einsum" class="anchor"></a><code><span>| </span><span><span class="constructor">Einsum</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The binary &quot;einsum&quot; syntax: RHS1;RHS2=&gt;LHS, where RHSi, LHS are labels specifications. Since OCANNL's extended einsum notation supports both axis variables and row variables, it makes other compose types redundant. The <code>axis_labels</code> use pseudo-labels local to the notation, to line up the axes and row variables. The symmetric difference / disjunctive union of RHS1 and RHS2's pseudo-labels should be equal to LHS pseudo-labels.</p><p>Note: The &quot;right-hand-side&quot; is on the left! I.e. the syntax is &quot;rhs=&gt;lhs&quot;, &quot;rhs1;rhs2=&gt;lhs&quot;.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_compose_type"><a href="#val-sexp_of_compose_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_compose_type : <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compose_type_of_sexp"><a href="#val-compose_type_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> compose_type_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-compose_type">compose_type</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_compose_type"><a href="#val-equal_compose_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_compose_type : <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-compose_type">compose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-transpose_type"><a href="#type-transpose_type" class="anchor"></a><code><span><span class="keyword">type</span> transpose_type</span><span> = </span></code><ol><li id="type-transpose_type.Transpose" class="def variant constructor anchored"><a href="#type-transpose_type.Transpose" class="anchor"></a><code><span>| </span><span><span class="constructor">Transpose</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Swaps inputs and outputs of a shape, preserves batch axes.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Pointwise_un" class="def variant constructor anchored"><a href="#type-transpose_type.Pointwise_un" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointwise_un</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Preserves the shape.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Permute" class="def variant constructor anchored"><a href="#type-transpose_type.Permute" class="anchor"></a><code><span>| </span><span><span class="constructor">Permute</span> <span class="keyword">of</span> <span class="xref-unresolved">Base</span>.string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The unary &quot;einsum&quot; syntax: RHS1=&gt;LHS.</p><span class="comment-delim">*)</span></div></li><li id="type-transpose_type.Batch_slice" class="def variant constructor anchored"><a href="#type-transpose_type.Batch_slice" class="anchor"></a><code><span>| </span><span><span class="constructor">Batch_slice</span> <span class="keyword">of</span> <a href="../../../arrayjit/Arrayjit/Indexing/index.html#type-static_symbol">Arrayjit.Indexing.static_symbol</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Removes the leftmost batch axis.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_transpose_type"><a href="#val-equal_transpose_type" class="anchor"></a><code><span><span class="keyword">val</span> equal_transpose_type : <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_transpose_type"><a href="#val-sexp_of_transpose_type" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_transpose_type : <span><a href="#type-transpose_type">transpose_type</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transpose_type_of_sexp"><a href="#val-transpose_type_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> transpose_type_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-transpose_type">transpose_type</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?batch_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?input_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?output_dims</span>:<span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?batch_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?input_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?output_axes</span>:<span><span>(<span class="xref-unresolved">Base</span>.string * <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?deduced</span>:<a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">debug_name</span>:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Creates a shape. <code>id</code> should be the id the associated tensor (if any). At most one of the pairs <code>batch_dims</code>, <code>batch_axes</code> etc. should be given: if none, the corresponding row will be inferred. <code>batch_axes</code> etc. provide labels for the dimensions of the corresponding axes. Note that these are dimensions labels and not axis labels: they need not be unique for a row, are inferred when provided, and must match whenever the axis sizes must match.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string_hum"><a href="#val-to_string_hum" class="anchor"></a><code><span><span class="keyword">val</span> to_string_hum : 
  <span><span class="optlabel">?style</span>:
    <span>[&lt; `Axis_number_and_size
    <span>| `Axis_size</span>
    <span>| `Only_labels</span> Axis_size Only_labels ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Base</span>.string</span></code></div></div><h3 id="internal-ish-api."><a href="#internal-ish-api." class="anchor"></a>Internal-ish API.</h3><div class="odoc-spec"><div class="spec type anchored" id="type-logic"><a href="#type-logic" class="anchor"></a><code><span><span class="keyword">type</span> logic</span><span> = </span></code><ol><li id="type-logic.Broadcast" class="def variant constructor anchored"><a href="#type-logic.Broadcast" class="anchor"></a><code><span>| </span><span><span class="constructor">Broadcast</span> <span class="keyword">of</span> <a href="#type-compose_type">compose_type</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Matches the shapes for a binary operation.</p><p>For <code>Broadcast (Einsum (ls1, ls2, ls3), s1, s2)</code>, the labels of <code>s1</code> and <code>s2</code> must match according to the <code>ls1</code>, <code>ls2</code> lineup, and the resulting shape inherits the labels according to the <code>ls3</code> lineup.</p><span class="comment-delim">*)</span></div></li><li id="type-logic.Transpose" class="def variant constructor anchored"><a href="#type-logic.Transpose" class="anchor"></a><code><span>| </span><span><span class="constructor">Transpose</span> <span class="keyword">of</span> <a href="#type-transpose_type">transpose_type</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Permutes the axes of a shape. One case of <code>Transpose</code> is to swap inputs with outputs of <code>s1</code>, hence the name.</p><span class="comment-delim">*)</span></div></li><li id="type-logic.Terminal" class="def variant constructor anchored"><a href="#type-logic.Terminal" class="anchor"></a><code><span>| </span><span><span class="constructor">Terminal</span> <span class="keyword">of</span> <a href="../../../arrayjit/Arrayjit/Ops/index.html#type-init_op">Arrayjit.Ops.init_op</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Extracts any available shape information from the initialization. E.g. for <code>File_mapped fn</code>, opens the file <code>fn</code> to check its length.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>How to propagate shape updates and do the last update of <code>Tensor.t.shape</code> when finalizing the tensor. Axes are broadcast-expanded on a bottom-up update to fit the incoming shape.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_logic"><a href="#val-equal_logic" class="anchor"></a><code><span><span class="keyword">val</span> equal_logic : <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_logic"><a href="#val-sexp_of_logic" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_logic : <span><a href="#type-logic">logic</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logic_of_sexp"><a href="#val-logic_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> logic_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-logic">logic</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-update_id"><a href="#type-update_id" class="anchor"></a><code><span><span class="keyword">type</span> update_id</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_update_id"><a href="#val-equal_update_id" class="anchor"></a><code><span><span class="keyword">val</span> equal_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_update_id"><a href="#val-compare_update_id" class="anchor"></a><code><span><span class="keyword">val</span> compare_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_fold_update_id"><a href="#val-hash_fold_update_id" class="anchor"></a><code><span><span class="keyword">val</span> hash_fold_update_id : 
  <span><span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.state</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_update_id"><a href="#val-hash_update_id" class="anchor"></a><code><span><span class="keyword">val</span> hash_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_hash_lib</span>.Std.Hash.hash_value</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_update_id"><a href="#val-sexp_of_update_id" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_update_id : <span><a href="#type-update_id">update_id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_id_of_sexp"><a href="#val-update_id_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> update_id_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-update_id">update_id</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_update_id"><a href="#val-get_update_id" class="anchor"></a><code><span><span class="keyword">val</span> get_update_id : <span><span class="xref-unresolved">Base</span>.unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-update_id">update_id</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-update_step"><a href="#type-update_step" class="anchor"></a><code><span><span class="keyword">type</span> update_step</span><span> = </span><span>{</span></code><ol><li id="type-update_step.shape" class="def record field anchored"><a href="#type-update_step.shape" class="anchor"></a><code><span>shape : <a href="#type-t">t</a>;</span></code></li><li id="type-update_step.logic" class="def record field anchored"><a href="#type-update_step.logic" class="anchor"></a><code><span>logic : <a href="#type-logic">logic</a>;</span></code></li><li id="type-update_step.id" class="def record field anchored"><a href="#type-update_step.id" class="anchor"></a><code><span>id : <a href="#type-update_id">update_id</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Data required for a shape inference update step. Ideally, an update should be performed at least twice, the second time after all the other relevant updates have been performed for the first time. In OCANNL, this is achieved by performing updates both as the tensors are constructed, and via lazy callbacks as the corresponding <code>Arrayjit.Indexing</code> dimensions and projections are first accessed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sexp_of_update_step"><a href="#val-sexp_of_update_step" class="anchor"></a><code><span><span class="keyword">val</span> sexp_of_update_step : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sexplib0</span>.Sexp.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_step_of_sexp"><a href="#val-update_step_of_sexp" class="anchor"></a><code><span><span class="keyword">val</span> update_step_of_sexp : <span><span class="xref-unresolved">Sexplib0</span>.Sexp.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-update_step">update_step</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_dims"><a href="#val-to_dims" class="anchor"></a><code><span><span class="keyword">val</span> to_dims : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-propagate_shapes"><a href="#val-propagate_shapes" class="anchor"></a><code><span><span class="keyword">val</span> propagate_shapes : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-derive_projections"><a href="#val-derive_projections" class="anchor"></a><code><span><span class="keyword">val</span> derive_projections : <span><a href="#type-update_step">update_step</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../arrayjit/Arrayjit/Indexing/index.html#type-projections">Arrayjit.Indexing.projections</a></span></code></div><div class="spec-doc"><p>Computes the indexing into subtensors given the shape information of a tensor. <code>derive_projections</code> should only be invoked when the shapes are fully inferred already!</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_spec"><a href="#val-of_spec" class="anchor"></a><code><span><span class="keyword">val</span> of_spec : 
  <span><span class="optlabel">?deduced</span>:<a href="#type-deduce_within_shape">deduce_within_shape</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">debug_name</span>:<span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">id</span>:<span class="xref-unresolved">Base</span>.int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-default_display_indices"><a href="#val-default_display_indices" class="anchor"></a><code><span><span class="keyword">val</span> default_display_indices : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.int <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_labels"><a href="#val-to_labels" class="anchor"></a><code><span><span class="keyword">val</span> to_labels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Base</span>.string <span class="xref-unresolved">Base</span>.array</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-axis_map"><a href="#type-axis_map" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a axis_map</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-parsed_axis_labels"><a href="#type-parsed_axis_labels" class="anchor"></a><code><span><span class="keyword">type</span> parsed_axis_labels</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_labels"><a href="#val-axis_labels" class="anchor"></a><code><span><span class="keyword">val</span> axis_labels : 
  <span><a href="#type-parsed_axis_labels">parsed_axis_labels</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="xref-unresolved">Base</span>.string, <span class="xref-unresolved">Base</span>.int)</span> <span class="xref-unresolved">Base</span>.Either.t</span> <a href="#type-axis_map">axis_map</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_labels_of_spec"><a href="#val-axis_labels_of_spec" class="anchor"></a><code><span><span class="keyword">val</span> axis_labels_of_spec : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <a href="#type-parsed_axis_labels">parsed_axis_labels</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_map_to_dims_index"><a href="#val-axis_map_to_dims_index" class="anchor"></a><code><span><span class="keyword">val</span> axis_map_to_dims_index : <span><span class="optlabel">?default</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-axis_map">axis_map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Base</span>.array</span></span></code></div></div></div></body></html>
